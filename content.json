[{"title":"NOI2018游记","date":"2018-07-20T11:18:32.000Z","path":"2018/07/20/noi2018/","text":"高一的最后一战啦QwQ 据说我能去NOI Day 0报到日。 开幕式彩排有毒..不是很懂台上那个人为什么觉得窝萌在配合她.. 晚上被鄙视背笔试。 看到了Starria和自转的negiizhao Day 1笔试顺利100100100。 我校似乎只有zhouyuyang被gedit 坑了拿了999999。 中午回了下寝室，脑子抽风爬到了上铺，然后把床板踩断了。。脚上还擦破了皮。。 redbag从雅礼跑了过来。 开幕式喊口号的环节还是有毒。。不想多说。 “太热了，不说了”海星。 晚上背板子颓。 Day 2(Contest Day 1)大自爆。 妄图去想T2结果啥都没想出来，最后写T3的282828分sam没写暴力，结果sam没调出来，T3爆蛋，T2状压DP也没写。。 一开始看到的得分是100+12+0=112100+12+0=112100+12+0=112，后来重测之后得分100+24+0=124100+24+0=124100+24+0=124。 wzp好像多组数据没清零导致T1挂成555分了，而且T3还有些点用了 内存QAQ，最后5+44+56=1055+44+56=1055+44+56=105。 SHENZHEBEI好像炸成了总分444444？？？感觉药丸。 zhouyuyangT2没开-O2，数组越界没注意到，结果T2808080分炸成了000分，最后100+0+68=168100+0+68=168100+0+68=168。 cqz超稳，100+52+68=220100+52+68=220100+52+68=220。 cogito被卡了444分，100+36+8=144100+36+8=144100+36+8=144。 negiizhao好像踢了三脚电源线，结果T1MLE爆蛋了。。 Starria在集训队线上，100+44+68=212100+44+68=212100+44+68=212。 lyx_cjzT3被卡了，100+80+36=216100+80+36=216100+80+36=216 晚上浪浪浪。 Day 3社会实践日。 早上被miaom教导之后发现自己T1的做法是log\\loglog的而不是log2\\log^2log​2​​的。（做法是每个下标开个vector实现可持久化数组） 犹豫很久还是跟着去了。 排队半小时，参观五分钟.jpg 宾馆午饭真香。 dt摸头翻车可还行 Day 4(Contest Day 2)考试之前看到考场里有九老师很慌，开考之后发现题目名有多边形更慌了，看了一眼T3心态好多了。。 看T1，发现是个要CRT的数论题，然后写写写，写到一半发现还要快速乘，写完已经快两个小时过去了。 然后看T2，写了暴力和链，当时以为自己ci=0c_i=0c​i​​=0的做法是满log2\\log^2log​2​​的就没写。 看T3，因为是九老师出的题不敢多思考，写了暴力O(2n×n2)O(2^n\\times n^2)O(2​n​​×n​2​​)就跑了。 最后一个小时检查的时候发现T1要开multiset，然后我改成multiset之后大样例WA了，当时一度觉得数据出锅了，最后才发现自己要upper_bound一个long long所以不能用multiset&lt;int&gt;。。 还有202020分钟的时候发现自己那个做法就是log\\loglog的，感觉自己是智障。。 估分100+30+20=150100+30+20=150100+30+20=150。 查分之前听说很多人都挂分了非常慌，然后发现居然没挂分。 zhouyuyang会T3505050，但是前两题挂了252525，最后80+40+50=17080+40+50=17080+40+50=170，算上笔试卡线金。 cqz100+45+5=150100+45+5=150100+45+5=150顺利集训队。 wzp100+45+0=145100+45+0=145100+45+0=145，居然总分没我高 SHENZHEBEI好像文件名打错炸成铁牌了QAQ cogitoT1也挂了202020，80+20+20=12080+20+20=12080+20+20=120 Starria好像炸成总分909090了QAQ lyx_cjz好像也炸了QAQ 窝算上D类以后139139139名，感觉自己好菜啊。 晚上换约，颓颓颓。 Day 5闭幕式海星。 fjzzq2002捧杯了Orz，“福州第三捧杯中学“ 听说我们的火车停开了，改签了到杭州的火车。 晚上写这篇游记（ 感觉dt一来三楼气氛就奇怪了很多（雾 Day 6然后到杭州的火车也停开了，继续改签到第二天回绍兴。 在奇怪的宾馆里颓废。 下午去橘子洲，感觉走了至少几万步（ 晚上颓三国杀。 Day 7滚粗回家啦。","tags":[{"name":"游记","slug":"游记","permalink":"https://q234rty.top/tags/游记/"}]},{"title":"Codeforces Round 446 (Div. 1) 题解","date":"2018-07-12T06:08:27.000Z","path":"2018/07/12/cf891/","text":"施工中QwQ A. Pride首先如果原序列中已经有111 ，答案是nnn减去111的个数。 否则一定是先构造出一个111，然后再用n−1n-1n−1步全部变成111。 设最短的gcd\\gcdgcd为111的区间长度为lll，那么答案为n+l−2n+l-2n+l−2。 时间复杂度O(n2logai)O(n^2 \\log a_i)O(n​2​​loga​i​​)，维护不同的gcd\\gcdgcd可以做到O(nlog2ai)O(n \\log^2 a_i)O(nlog​2​​a​i​​)。 Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=10000020; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(\"891A.txt\",\"r\",stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]='\\0'; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!='-';bufpos++); bufpos+=(isneg=buf[bufpos]=='-'); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-'0'; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-'0'; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]='\\0'; return cur; } int a[2003]; int main(){ init(); int n=readint(),ans=n+1; // puts(\"WTF\"); for(int i=1;i&lt;=n;i++){ a[i]=readint(); int now=0; for(int j=i;j;j--){ now=__gcd(now,a[j]); if (now==1){ ans=min(ans,i-j+1); break; } } } // puts(\"WTF\"); if (ans&gt;n) return puts(\"-1\"),0; if (ans==1){ int qwq=n; for(int i=1;i&lt;=n;i++) qwq-=(a[i]==1); printf(\"%d\\n\",qwq); return 0; } printf(\"%d\",ans-1+n-1); } B. Gluttony 一直在想状压DP，看了题解才发现n≤22n \\leq 22n≤22只是因为spj需要O(2n)O(2^n)O(2​n​​)而已。 将每个数变成第一个比它大的数（如果不存在则变成最小的数）即可。 证明： 对于每个不包含原排列中最大数的下标集合显然成立，否则考虑取补集可以发现仍然成立。 Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=10000020; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(\"891B.txt\",\"r\",stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]='\\0'; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!='-';bufpos++); bufpos+=(isneg=buf[bufpos]=='-'); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-'0'; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-'0'; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]='\\0'; return cur; } pair&lt;int,int&gt; a[233]; int ans[233]; int main(){ init(); int n=readint(); for(int i=1;i&lt;=n;i++) a[i].first=readint(),a[i].second=i; sort(a+1,a+n+1); for(int i=1;i&lt;n;i++) ans[a[i].second]=a[i+1].first; ans[a[n].second]=a[1].first; for(int i=1;i&lt;=n;i++) printf(\"%d \",ans[i]); } //1 2 3 4 //2 3 4 1 C. Envy算法导论上有这样一个结论：一张图的任何一个最小生成树均可以通过在Kruskal中改变相同权值的边的排列顺序得到。 于是考虑把每个询问中的边按权值分组，离线，然后在Kruskal的过程中判断一组中的边同时加入会不会产生环即可。需要带撤销的并查集，注意只需要按秩合并，路径压缩的复杂度是均摊的。 时间复杂度O((m+∑k)logn)O((m+\\sum k) \\log n)O((m+∑k)logn)。 Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=100000020; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(\"891C.txt\",\"r\",stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]='\\0'; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!='-';bufpos++); bufpos+=(isneg=buf[bufpos]=='-'); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-'0'; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-'0'; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]='\\0'; return cur; } const int maxn=500002; struct dsu{ int fa[maxn],rk[maxn]; pair&lt;int,int&gt; stk[maxn*20]; int tp; void init(int n){ for(int i=1;i&lt;=n;i++) fa[i]=i,rk[i]=0; tp=0; } void revert(int ver){ while(tp!=ver){ int x=stk[tp].first,y=stk[tp].second; if (x&gt;0) fa[x]=y; else rk[-x]=y; tp--; } } int getf(int x){ while(fa[x]!=x) x=fa[x]; return x; } bool mer(int x,int y){ x=getf(x),y=getf(y); if (x==y) return false; if (rk[x]&gt;rk[y]) swap(x,y); stk[++tp]=make_pair(x,fa[x]); stk[++tp]=make_pair(-y,rk[y]); fa[x]=y; rk[y]=max(rk[y],rk[x]+1); return true; } }d; struct edge{ int u,v,w,id; bool operator &lt;(const edge&amp; rhs)const{ return w&lt;rhs.w; } }e[maxn]; int to[maxn],lst[maxn]; struct query{ int id; vector&lt;int&gt; a; }; vector&lt;query&gt; q[maxn]; bool ans[maxn]; int main(){ init(); int n=readint(),m=readint(); for(int i=1;i&lt;=m;i++) e[i].id=i,e[i].u=readint(),e[i].v=readint(),e[i].w=readint(); sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++){ to[e[i].id]=i; lst[i]=e[i].w==e[i-1].w?lst[i-1]:i; } int cnt=readint(); for(int i=1;i&lt;=cnt;i++){ ans[i]=1; int k=readint(); while(k--){ int p=to[readint()]; if (q[lst[p]].empty() || q[lst[p]].back().id!=i) q[lst[p]].push_back((query){i}); q[lst[p]].back().a.push_back(p); } } d.init(n); for(int i=1;i&lt;=m;i++){ if (q[i].size()){ for(const auto&amp; u:q[i]){ int ver=d.tp; for(const auto&amp; v:u.a){ if (!d.mer(e[v].u,e[v].v)){ ans[u.id]=0; break; } } d.revert(ver); } } d.mer(e[i].u,e[i].v); } for(int i=1;i&lt;=cnt;i++) puts(ans[i]?\"YES\":\"NO\"); } D. Sloth 留坑 E. Lust设第iii个数被减了bib_ib​i​​次。 首先归纳可证res=∏iai−∏i(ai−bi)res=\\prod_{i}a_i-\\prod_{i}(a_i-b_i)res=∏​i​​a​i​​−∏​i​​(a​i​​−b​i​​)。 那么 Eres=∏i=1nai−k!nk∑b1+b2+⋯+bn=k∏i=1nai−bibi! \\mathbb{E}_{res}=\\prod_{i=1}^na_i-\\frac{k!}{n^k}\\sum_{b_1+b_2+\\cdots+b_n=k}\\prod_{i=1}^n\\frac{a_i-b_i}{b_i!} E​res​​=​i=1​∏​n​​a​i​​−​n​k​​​​k!​​​b​1​​+b​2​​+⋯+b​n​​=k​∑​​​i=1​∏​n​​​b​i​​!​​a​i​​−b​i​​​​注意到 ∑b1+b2+⋯+bn=k∏i=1nai−bibi!=[xk]∏i=1n∑j=0kai−jj!xj=[xk]∏i=1n(aiex−xex)=[xk]enx∏i=1n(ai−x) \\begin{aligned} \\sum_{b_1+b_2+\\cdots+b_n=k}\\prod_{i=1}^n\\frac{a_i-b_i}{b_i!}&amp;=[x^k]\\prod_{i=1}^n\\sum_{j=0}^k\\frac{a_i-j}{j!}x^j \\\\ &amp;=[x^k]\\prod_{i=1}^n(a_ie^x-xe^x)\\\\ &amp;=[x^k]e^{nx}\\prod_{i=1}^n(a_i-x) \\end{aligned} ​​b​1​​+b​2​​+⋯+b​n​​=k​∑​​​i=1​∏​n​​​b​i​​!​​a​i​​−b​i​​​​​​​​​=[x​k​​]​i=1​∏​n​​​j=0​∑​k​​​j!​​a​i​​−j​​x​j​​​=[x​k​​]​i=1​∏​n​​(a​i​​e​x​​−xe​x​​)​=[x​k​​]e​nx​​​i=1​∏​n​​(a​i​​−x)​​设∏i=1n(ai−x)=∑i=0ncixi\\prod_{i=1}^n(a_i-x)=\\sum_{i=0}^nc_ix^i∏​i=1​n​​(a​i​​−x)=∑​i=0​n​​c​i​​x​i​​，我们O(n2)O(n^2)O(n​2​​)暴力求出 。 于是 [xk]enx∏i=1n(ai−x)=∑i=0ncink−i(k−i)! [x^k]e^{nx}\\prod_{i=1}^n(a_i-x)=\\sum_{i=0}^nc_i\\frac{n^{k-i}}{(k-i)!} [x​k​​]e​nx​​​i=1​∏​n​​(a​i​​−x)=​i=0​∑​n​​c​i​​​(k−i)!​​n​k−i​​​​那么 时间复杂度O(n2)O(n^2)O(n​2​​)。 Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=10000020; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(\"891E.txt\",\"r\",stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]='\\0'; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!='-';bufpos++); bufpos+=(isneg=buf[bufpos]=='-'); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-'0'; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-'0'; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]='\\0'; return cur; } const int mod=1000000007; ll a[5003]; ll power(ll x,ll y){ ll ans=1; while(y){ if (y&amp;1) ans=ans*x%mod; x=x*x%mod; y&gt;&gt;=1; } return ans; } int main(){ init(); int n=readint(); ll k=readint(),ans=1; a[0]=1; for(int i=1;i&lt;=n;i++){ ll x=readint(); ans=ans*x%mod; for(int j=i-1;j&gt;=0;j--){ a[j+1]=(a[j+1]-a[j])%mod; a[j]=a[j]*x%mod; } } ll now=1,pw=1; ll inv=power(n,mod-2); for(int i=0;i&lt;=n;i++){ ans=(ans-now*pw%mod*a[i])%mod; now=now*(k-i)%mod; pw=pw*inv%mod; } printf(\"%lld\",(ans%mod+mod)%mod); }","tags":[{"name":"概率和期望","slug":"概率和期望","permalink":"https://q234rty.top/tags/概率和期望/"},{"name":"组合数学","slug":"组合数学","permalink":"https://q234rty.top/tags/组合数学/"},{"name":"数论","slug":"数论","permalink":"https://q234rty.top/tags/数论/"},{"name":"构造","slug":"构造","permalink":"https://q234rty.top/tags/构造/"},{"name":"并查集","slug":"并查集","permalink":"https://q234rty.top/tags/并查集/"},{"name":"生成函数","slug":"生成函数","permalink":"https://q234rty.top/tags/生成函数/"}]},{"title":"【LOJ2523】【BZOJ5302】【HAOI2018】奇怪的背包","date":"2018-06-11T05:51:56.000Z","path":"2018/06/11/loj2523/","text":"裴蜀定理+容斥即可。 首先考虑经典的裴蜀定理：∑i=1nxiai=d\\sum_{i=1}^nx_ia_i=d∑​i=1​n​​x​i​​a​i​​=d有整数解当且仅当gcd(a1,a2,⋯,an)∣d\\gcd(a_1,a_2,\\cdots,a_n) \\mid dgcd(a​1​​,a​2​​,⋯,a​n​​)∣d。 注意本题并不需要非负的条件，因为可以用PPP来调整。 于是问题就变成了求 ∑S∈Vi[gcd(S,P)∣wi] \\sum_{S\\in V_i}[\\gcd(S,P)\\mid w_i] ​S∈V​i​​​∑​​[gcd(S,P)∣w​i​​]首先ViV_iV​i​​和wiw_iw​i​​显然都可以先和PPP取gcd\\gcdgcd。 然后设kkk为PPP的约数个数，根据vfk的blog，当P≤109P\\le 10^9P≤10​9​​时有k≤1344k \\le 1344k≤1344。 那么我们考虑先对于每个x∣Px\\mid Px∣P求出 ∑S∈Vi[x∣gcd(S,P)] \\sum_{S\\in V_i}[x \\mid\\gcd(S,P)] ​S∈V​i​​​∑​​[x∣gcd(S,P)]显然这就是2m−12^m-12​m​​−1，其中 m=∑i=1n[x∣ai] m=\\sum_{i=1}^n[x \\mid a_i] m=​i=1​∑​n​​[x∣a​i​​]O(k2)O(k^2)O(k​2​​)暴力即可。 之后我们O(k2)O(k^2)O(k​2​​)暴力容斥求得 ∑S∈Vi[x=gcd(S,P)] \\sum_{S\\in V_i}[x =\\gcd(S,P)] ​S∈V​i​​​∑​​[x=gcd(S,P)]然后再O(k2)O(k^2)O(k​2​​)统计答案即可。 时间复杂度O(k2+(n+q)logk)O(k^2+(n+q) \\log k)O(k​2​​+(n+q)logk)。 Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=20000020; const int mod=1000000007; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(&quot;2532.txt&quot;,&quot;r&quot;,stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=buf[bufpos]==&#39;-&#39;); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } int d[2002]; ll cnt[2002]; int pw[1000002]; int main(){ init(); int n=readint(),q=readint(),p=readint(),cur=0; for(int i=1;i*i&lt;=p;i++) if (p%i==0){ d[++cur]=i; if (i*i!=p) d[++cur]=p/i; } sort(d+1,d+cur+1); pw[0]=1; for(int i=1;i&lt;=n;i++){ pw[i]=pw[i-1]*2; if (pw[i]&gt;=mod) pw[i]-=mod; } while(n--) cnt[lower_bound(d+1,d+cur+1,__gcd(readint(),p))-d]++; for(int i=1;i&lt;=cur;i++) for(int j=i+1;j&lt;=cur;j++) if (d[j]%d[i]==0) cnt[i]+=cnt[j]; for(int i=1;i&lt;=cur;i++) cnt[i]=pw[cnt[i]]-1; for(int i=cur;i;i--){ for(int j=i+1;j&lt;=cur;j++) if (d[j]%d[i]==0) cnt[i]-=cnt[j]; cnt[i]%=mod; } for(int i=cur;i;i--){ for(int j=1;j&lt;i;j++) if (d[i]%d[j]==0) cnt[i]+=cnt[j]; cnt[i]=(cnt[i]%mod+mod)%mod; } while(q--) printf(&quot;%lld\\n&quot;,cnt[lower_bound(d+1,d+cur+1,__gcd(readint(),p))-d]); }","tags":[{"name":"计数","slug":"计数","permalink":"https://q234rty.top/tags/计数/"},{"name":"容斥原理","slug":"容斥原理","permalink":"https://q234rty.top/tags/容斥原理/"},{"name":"数论","slug":"数论","permalink":"https://q234rty.top/tags/数论/"}]},{"title":"【BZOJ5366】【Lydsy1805月赛】代码派对","date":"2018-05-29T04:29:31.000Z","path":"2018/05/29/bzoj5366/","text":"容斥+二维前缀和即可。 首先一个naive的想法是枚举一个点(x,y)(x,y)(x,y)，用二维前缀和预处理出有多少个矩形包含(x,y)(x,y)(x,y)，设有kkk个，那么给答案加上(k3)\\binom{k}{3}(​3​k​​)。但是这样显然会算重。 注意到333个矩形的交要么是空，要么还是矩形，我们考虑只在交的左上角计数这333个矩形一次。也就是说，对于每个点(x,y)(x,y)(x,y)，我们要算有多少矩形三元组的交包含这个点，但是不包含(x−1,y)(x-1,y)(x−1,y)和(x,y−1)(x,y-1)(x,y−1)。 考虑容斥，可以发现这就等于包含(x,y)(x,y)(x,y)的矩形三元组的数量，减去同时包含(x,y)(x,y)(x,y)和(x−1,y)(x-1,y)(x−1,y)的矩形三元组的数量，减去同时包含(x,y)(x,y)(x,y)和(x,y−1)(x,y-1)(x,y−1)的矩形三元组的数量，再加上同时包含(x,y)(x,y)(x,y)和(x−1,y)(x-1,y)(x−1,y)和(x,y−1)(x,y-1)(x,y−1)的矩形三元组的数量。后面三个量的计算和第一个是类似的，只是要把矩形缩小一行和/或一列，直接二维前缀和即可。 时间复杂度O(T(n+10002))O(T(n+1000^2))O(T(n+1000​2​​)) Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=10000020; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(&quot;5366.txt&quot;,&quot;r&quot;,stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=buf[bufpos]==&#39;-&#39;); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } ll c3(ll n){ return n*(n-1)*(n-2); } struct qwq{ int t[1002][1002]; void init(){ memset(t,0,sizeof(t)); } void add(int x1,int y1,int x2,int y2,int v){ if (x1&gt;x2 || y1&gt;y2) return; t[x1][y1]+=v; t[x1][y2+1]-=v; t[x2+1][y1]-=v; t[x2+1][y2+1]+=v; } void get(){ for(int i=1;i&lt;=1000;i++) for(int j=1;j&lt;=1000;j++) t[i][j]+=t[i-1][j]+t[i][j-1]-t[i-1][j-1]; } int * operator [](int x){ return t[x]; } }a,b,c,d; int main(){ init(); int T=readint(); while(T--){ int n=readint(); a.init(),b.init(),c.init(),d.init(); while(n--){ int x1=readint(),y1=readint(),x2=readint(),y2=readint(); a.add(x1,y1,x2,y2,1); b.add(x1+1,y1,x2,y2,1); c.add(x1,y1+1,x2,y2,1); d.add(x1+1,y1+1,x2,y2,1); } a.get(),b.get(),c.get(),d.get(); ll ans=0; for(int i=1;i&lt;=1000;i++) for(int j=1;j&lt;=1000;j++) ans+=c3(a[i][j])-c3(b[i][j])-c3(c[i][j])+c3(d[i][j]); printf(&quot;%lld\\n&quot;,ans/6); } }","tags":[{"name":"计数","slug":"计数","permalink":"https://q234rty.top/tags/计数/"},{"name":"容斥原理","slug":"容斥原理","permalink":"https://q234rty.top/tags/容斥原理/"}]},{"title":"CTSC&APIO2018滚粗记","date":"2018-05-07T14:30:59.000Z","path":"2018/05/07/ctsc2018/","text":"滚粗啦QwQ 这个博客似乎荒废的有点久了？最近的更新似乎都在折腾看板娘 不过窝也AFO了，不会有什么时间了QwQ Day 0乘火车到了北京。 得到了THUPC窝萌队没过审的消息，差评哦QwQ Day 1报到日。 据说不用换房间了？妙啊。 被骗来八十中吃饭之后发现试机14:30才开始，再加上自己去年在同样的地方试过机，果断鸽了试机回宾馆。 下午跟着一群人出去逛公园，中途被cogito和zhouyuyang抛弃了。 Day 2 (CTSC Contest Day1)开场看T1，以为不可做。于是先去写了T2的 454545 分暴力，当时没有想到RMQ，于是O(n2)O(n^2)O(n​2​​)预处理了每对点的LCA，还用了一些奇怪的技巧开了一半的数组。 然后回来看T1，发现 707070 分好像很简单？于是就去写了一个过了大样例，然而大样例并撑不满 707070 分的数据范围，感觉有点虚，于是稍微卡了下常。 然后写了T3的 252525 分，本来想写T2的链的部分分，然后在我后面的zx2003问了一句111是不是一定在链的端点上，被告知不是，于是弄得窝不敢写了，再加上以为T1标算要多项式，最后一个小时就在犹豫不决之中过去了。 出来被告知T1是sb题，于是成功发现自己是一个不会退背包的智障选手。 下午在咕咕咕之后看到了分数，发现自己T2还多了输出第一棵树的边权和的151515分，最后得分70+60+25=15570+60+25=15570+60+25=155。 zhouyuyang和wzp都正常发挥，接近 200200200 分。 cogito似乎因为建了子文件夹爆0了，SHENZHEBEI因为输出优化里的某个东西忘删了连坐爆0了。 发现T2那个部分分111就是端点，感觉自己被误导了QwQ 感觉要打铁回家了。 Day 3早上鸽了答辩，和cogito、redbag、Fop_zz去陶然亭玩，然后就被婊了QwQ。晚上303里好像有cogito、negiizhao、Starria和redbag对拍？ Day 4 (CTSC Contest Day2)开场看T1，发现是sb题，写了个O(nlog2n)O(n \\log^2n)O(nlog​2​​n)的二分+主席树，过了大样例就放着了。 然后看T2，感觉普通的暴搜很难写而且可能没分，于是先放着去做T3。 写了个模拟器，暴搜了两个点，写了个背包过了3。然后随机骗了下后面几个点的分。这时回去看T2，感觉可以枚举每个问号是不是逗号然后贪心，大概就能稳过 202020 分？窝决定去写这个东西，最后写完了过了小样例没时间调，就滚粗了。 出来得知T3直接退火就有808080，感觉要打铁。 最后成绩100+0+43=143100+0+43=143100+0+43=143，T2意料之中的挂了。 zhouyuyang和wzp继续正常发挥，感觉他们应该都有Au？ cogito好像T1有一个错误在不开O2的情况下没表现出来，开了O2之后挂成202020了QwQ。 SHENZHEBEI好像比我少一分？ 好像有858585个人的程序被CCF丢了？怎么出这么大锅啊。。 换了一波胸牌，好像形成了四元环？ Day 5AOIP2008APIO2018报到日。 在宾馆里颓颓颓。 redbag好像去考Day3了？据说是原题重考？ CTSC的胸牌好像被换回来了（303里好像有cogito、negiizhao、Starria。据说negiizhao和Starria在里面对视了777小时？晚上redbag来303之后气氛好像有所好转？ Day 6换了一波胸牌，环内人数已经数不清了（ 上午讲了二分和图的匹配，还是认真听了下的QwQ 下午讲折纸和图像处理，全程颓废。cogito好像去了6楼被negiizhao摔跤？ Day 7 (APIO Contest)开场看T1，感觉自己会一个不知道几只log，特判之后大概有 707070 分的做法？ 于是先放了下T1，看了下T2和T3，感觉都很不可做。。 于是写了T2的O(n2)O(n^2)O(n​2​​)和T3的森林。 然后开T1，写完只有删除的部分分之后开始犹豫是不是要拼上线段树分治去拿252525，决定写一发，然而写完交上去WA还有半个小时，很怕调不出来，最后还是弃疗把暴力和T3的degree≤2degree \\leq 2degree≤2的部分分写了下。 最后得分45+7+31=8345+7+31=8345+7+31=83。 出来发现zx2003T3AC了，仔细想下好像并不难？早知道写完T1 454545 分就去写T3了 cogito好像KD-Tree乱搞过了T2？好像jzqjzq和axs7384T3分都很高？ zhouyuyang和SHENZHEBEI好像炸了？ 讲题时cogito自称redbag上去讲T2，太强辣。cogito好像换来了Starria的胸牌，并且保留到了结束？ 晚上和wzp他们打三国杀，赢了两局，有一局万剑放死两个人然后被小乔弹死，果然滚粗了之后打三国杀都能赢了 Day 8去不了THUPC差评。 早上讲底层优化，感觉很有趣（ 中午去奇怪的商业中心吃饭。 下午讲SAM，不是很想听就颓了一个下午QwQ 晚上颁奖，拿了两个Ag滚粗了。 cogitoAPIO Au，jzqjzq两场都被卡线了，axs7384APIO成功卡线Au。 wzp双Au，zhouyuyangAu+Ag，SHENZHEBEI一场没牌一场Cu（震惊，浙江A队爷竞然。。 花絮：主持人念出了&quot;宁波市填海蛟川书院&quot;，&quot;终于有人念对学校名了&quot;cogito成功要到了Starria的签名（ Day 9滚粗回家啦。 感觉这几次比赛或多或少都有些失误？菜得抠脚QwQ 反正窝也AFO了，祝各位能去NOI的NOI rp++，祝自己高二赛季好运QwQ","tags":[{"name":"游记","slug":"游记","permalink":"https://q234rty.top/tags/游记/"}]},{"title":"【Codeforces961G】Partitions","date":"2018-04-04T18:30:47.000Z","path":"2018/04/05/cf961g/","text":"组合数与Stirling数。 下文所说的Stirling数均指第二类Stirling数。 首先枚举∣S∣|S|∣S∣可以得到： 那么问题是如何求 问题是，据我所知并没有很好的快速对于每个iii求出 的方法。那怎么办办呢？只能推式子咯。 首先我们翻开具体数学，注意到不带容斥系数的组合数乘以Stirling数的和的公式只有下面这个： 那么就决定是你了，接下来我们来看怎么用这个化简上面那个式子。 注意到i(ni)=n(n−1i−1)i\\binom{n}{i}=n\\binom{n-1}{i-1}i(​i​n​​)=n(​i−1​n−1​​)，(ni)=(n−1i)+(n−1i−1)\\binom{n}{i}=\\binom{n-1}{i}+\\binom{n-1}{i-1}(​i​n​​)=(​i​n−1​​)+(​i−1​n−1​​)： 于是： 那么剩下的问题是怎么计算Stirling数。 算上集合的排列顺序，容斥一波可以发现： 于是预处理阶乘就可以O(klogn)O(k \\log n)O(klogn)计算了。 总时间复杂度O(klogn)O(k \\log n)O(klogn)。 Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=10000020; const int mod=1000000007; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(\"961G.txt\",\"r\",stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]='\\0'; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!='-';bufpos++); bufpos+=(isneg=buf[bufpos]=='-'); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-'0'; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-'0'; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]='\\0'; return cur; } ll power(ll x,ll y){ x%=mod; ll ans=1; while(y){ if (y&amp;1) ans=ans*x%mod; x=x*x%mod; y&gt;&gt;=1; } return ans; } ll fac[200002],invf[200002]; ll c(int n,int m){ if (n&lt;m) return 0; return fac[n]*invf[m]%mod*invf[n-m]%mod; } ll s(int n,int m){ ll ans=0; for(int i=1;i&lt;=m;i++){ ll now=power(i,n)*c(m,i)%mod; if ((m-i)%2) ans-=now; else ans+=now; } return ans%mod*invf[m]%mod; } int main(){ init(); int n=readint(),k=readint(); ll sum=0; for(int i=1;i&lt;=n;i++) sum+=readint(); sum%=mod; fac[0]=1; for(int i=1;i&lt;=n;i++) fac[i]=fac[i-1]*i%mod; invf[n]=power(fac[n],mod-2); for(int i=n;i;i--) invf[i-1]=invf[i]*i%mod; ll ans=(s(n,k)+(n-1)*s(n-1,k))%mod*sum%mod; printf(\"%lld\",(ans+mod)%mod); }","tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://q234rty.top/tags/组合数学/"},{"name":"Stirling数","slug":"Stirling数","permalink":"https://q234rty.top/tags/Stirling数/"}]},{"title":"【BZOJ5129】【Lydsy1712月赛】树上传送","date":"2018-04-02T21:46:56.000Z","path":"2018/04/03/bzoj5129/","text":"点分治+最短路即可。 首先看到距离不超过某个数的限制可以想到点分治。 我们建出原树的点分树，对于每个根我们bfs一遍，得到它子树中的节点到根的距离以及按到根的距离排序后的序列。 考虑Dijkstra算法，传统的Dijkstra中每个点可能被松弛成功多次，但是这题每个点所有出边的权值都是相同的，我们每次取wi=disi+costiw_i=dis_i+cost_iw​i​​=dis​i​​+cost​i​​最小的点出来松弛，就可以保证每个点第一次被松弛成功就是最优的，于是我们可以将这个点删去。 这样我们每次拿出来wiw_iw​i​​最小的点uuu，枚举其和要松弛的点的lcalcalca，将其子树中的点按照距离从小到大松弛就可以了。具体实现时类似当前弧。 至于点分治的写法，安利11Dimensions的写法QwQ Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; typedef pair&lt;ll,int&gt; pli; const int MAXSIZE=10000020; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(&quot;5129.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;5129.out&quot;,&quot;w&quot;,stdout); #endif buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=buf[bufpos]==&#39;-&#39;); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } const int maxn=300002; const int maxm=600002; const int nlgn=maxn*20; struct graph{ int n,m; struct edge{ int to,next; }e[maxm]; int first[maxn]; void addedge(int from,int to){ e[++m]=(edge){to,first[from]}; first[from]=m; } int sz[maxn]; bool vis[maxn]; int d[maxn][21]; int gs(int u,int fa){ sz[u]=1; for(int i=first[u];i;i=e[i].next){ int v=e[i].to; if (v!=fa &amp;&amp; !vis[v]) sz[u]+=gs(v,u); } return sz[u]; } int h; int ctrd(int u,int fa){ for(int i=first[u];i;i=e[i].next){ int v=e[i].to; if (v!=fa &amp;&amp; !vis[v] &amp;&amp; sz[v]&gt;h) return ctrd(v,u); } return u; } int qwq[nlgn]; int st[maxn],en[maxn],cur; int dep[maxn]; void bfs(int s,int ly){ cur++; int l=cur,r=cur; qwq[cur]=s; d[s][ly]=0; while(l&lt;=r){ int u=qwq[l++]; for(int i=first[u];i;i=e[i].next){ int v=e[i].to; if (d[v][ly]!=-1 || vis[v]) continue; d[v][ly]=d[u][ly]+1; qwq[++r]=v; } } cur=r; } int f[maxn]; int dcomp(int u,int ly){ h=gs(u,0)/2; int rt=ctrd(u,0); vis[rt]=1; st[rt]=cur+1; dep[rt]=ly; bfs(rt,ly); en[rt]=cur; for(int i=first[rt];i;i=e[i].next){ int v=e[i].to; if (!vis[v]) f[dcomp(v,ly+1)]=rt; } return rt; } priority_queue&lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt; &gt; q; int lim[maxn],cost[maxn]; ll w[maxn]; void dijkstra(int s){ memset(w,0x3f,(n+1)*8); w[s]=cost[s]; q.push(make_pair(w[s],s)); while(!q.empty()){ pli p=q.top(); q.pop(); int u=p.second,tat=u; while(u){ for(int&amp; i=st[u];i&lt;=en[u];i++){ //看起来很像当前弧？喵啊 int v=qwq[i]; int dis=d[tat][dep[u]]+d[v][dep[u]]; if (dis&gt;lim[tat]) break; if (p.first+cost[v]&lt;w[v]){ w[v]=p.first+cost[v]; q.push(make_pair(w[v],v)); } } u=f[u]; } } } void work(int s){ memset(d,-1,sizeof(d)); dcomp(1,0); dijkstra(s); } }g; int main(){ init(); int n=g.n=readint(),s=readint(); for(int i=1;i&lt;n;i++){ int u=readint(),v=readint(); g.addedge(u,v); g.addedge(v,u); } for(int i=1;i&lt;=n;i++) g.lim[i]=readint(),g.cost[i]=readint(); g.work(s); for(int i=1;i&lt;=n;i++) printf(&quot;%lld\\n&quot;,g.w[i]-g.cost[i]); }","tags":[{"name":"点分治","slug":"点分治","permalink":"https://q234rty.top/tags/点分治/"},{"name":"最短路","slug":"最短路","permalink":"https://q234rty.top/tags/最短路/"}]},{"title":"【BZOJ5092】【Lydsy1711月赛】分割序列","date":"2018-03-24T22:53:32.000Z","path":"2018/03/25/bzoj5092/","text":"超集和变换即可。 设si=⨁j=1iajs_i=\\bigoplus_{j=1}^ia_js​i​​=⨁​j=1​i​​a​j​​，容易看出原题相当于对于每个iii ，求sj+sj⊕si(1≤j≤i)s_j+s_j \\oplus s_i(1 \\leq j \\leq i)s​j​​+s​j​​⊕s​i​​(1≤j≤i)的最大值。 考虑分离出sis_is​i​​，注意到异或可以被看成不退位减法: a⊕b=a−b+2×((¬a)∧b) a\\oplus b=a-b+2\\times ((\\lnot a) \\land b) a⊕b=a−b+2×((¬a)∧b)于是sj+sj⊕si=si+2×((¬si)∧sj)s_j+s_j \\oplus s_i=s_i+2\\times ((\\lnot s_i) \\land s_j)s​j​​+s​j​​⊕s​i​​=s​i​​+2×((¬s​i​​)∧s​j​​)，我们只需求出(¬si)∧sj(\\lnot s_i) \\land s_j(¬s​i​​)∧s​j​​的最大值即可。 注意到一个数的超集不会比他本身更劣，可以想到使用超集和变换求出每个数的超集的最小出现时间。 然后直接按位贪心就好了。 时间复杂度O((n+ai)logai)O((n+a_i) \\log a_i)O((n+a​i​​)loga​i​​)。 Code //x+(sum^x)=sum+2*(x&amp;(~sum)) #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=10000020; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(&quot;5092.txt&quot;,&quot;r&quot;,stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=buf[bufpos]==&#39;-&#39;); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } int a[300002],f[1&lt;&lt;20]; int query(int x,int t){ //f[]&lt;=t int ans=0; for(int i=19;i&gt;=0;i--) if (x&gt;&gt;i&amp;1){ int qwq=ans|(1&lt;&lt;i); if (f[qwq]&lt;=t) ans=qwq; } return ans; } int main(){ init(); int n=readint(); memset(f,0x3f,sizeof(f)); f[0]=0; for(int i=1;i&lt;=n;i++){ a[i]=readint()^a[i-1]; f[a[i]]=min(f[a[i]],i); } for(int i=0;i&lt;20;i++) for(int j=0;j&lt;(1&lt;&lt;20);j++) if (!(j&gt;&gt;i&amp;1)) f[j]=min(f[j],f[j^(1&lt;&lt;i)]); for(int i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,a[i]+2*query(~a[i],i)); }","tags":[{"name":"位运算","slug":"位运算","permalink":"https://q234rty.top/tags/位运算/"}]},{"title":"【UOJ290】【LOJ2250】【ZJOI2017】仙人掌","date":"2018-03-04T05:53:34.000Z","path":"2018/03/04/uoj290/","text":"神仙数数题 （终于没有即可了233 首先，为了方便我们把每条不在任何一个环上的边加一条重边，视为在一个长度为222的环上。也就是说，把仙人掌的定义中没有重边且每条边在不超过一个环上改为可能有重边且每条边在刚好一个环上。 我们考虑原图是树的情况，设f(u)f(u)f(u)为uuu的子树中连边，并且选择一个点连向子树外（由于每条边在刚好一个环上，一定恰好有一个这样的点，我们称这个点为黑点），使得uuu的子树成为仙人掌的方案数。 考虑uuu的所有儿子的子树的黑点连向哪里。当uuu为根时，这些点要么连向uuu（视为不配对），要么两两配对。否则，这些点中一定有不超过一个点连向uuu的子树外（成为新的黑点），我们认为这是和uuu子树外的联通块配对，如果没有，那么就是uuu成为新的黑点，视为uuu子树外的联通块不配对，而其它点和uuu为根的情况一样。 总之，设h(n)h(n)h(n)为nnn个点两两配对（可以不配对）的方案数。那么由乘法原理： f(u)=h(deg(u))×∏v∈son(u)f(v) f(u)=h(deg(u))\\times\\prod_{v \\in son(u)} f(v) f(u)=h(deg(u))×​v∈son(u)​∏​​f(v)其中deg(u)deg(u)deg(u)表示uuu的度数，son(u)son(u)son(u)表示uuu的儿子节点集合。 而h(n)h(n)h(n)可以直接递推： h(n)=h(n−1)+(n−1)×h(n−2) h(n)=h(n-1)+(n-1) \\times h(n-2) h(n)=h(n−1)+(n−1)×h(n−2)这样就解决了原图是树的情况。 如果原图不是树，我们dfs出一棵生成树和一些返祖边，利用树上差分找出所有被返祖边覆盖过的边，特别的，如果有边被覆盖两次说明原图不是仙人掌，答案显然为000。否则我们把返祖边和被覆盖的边全部删去，得到一个森林，由于各个连通块之间显然不能连边，把各个连通块的答案乘起来就行了。 如果看不懂可以去看看cogito的题解。 Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=20000020; const int mod=998244353; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(&quot;290.txt&quot;,&quot;r&quot;,stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=buf[bufpos]==&#39;-&#39;); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } const int maxn=500004; const int maxm=maxn*4; ll h[maxn]; struct graph{ int n,m; struct edge{ int to,next; bool del; }e[maxm]; int first[maxn],cnt[maxn]; void init(int n){ this-&gt;n=n; memset(first,0,(n+1)*4); memset(cnt,0,(n+1)*4); m=1; } void addedge(int from,int to){ e[++m]=(edge){to,first[from],0}; first[from]=m; } bool vis[maxn]; void dfs(int u,int fa){ vis[u]=1; for(int i=first[u];i;i=e[i].next){ int v=e[i].to; if (!vis[v]) dfs(v,u); else if (v!=fa &amp;&amp; !e[i].del){ e[i].del=e[i^1].del=1; cnt[v]--,cnt[u]++; // printf(&quot;233 %d %d\\n&quot;,v,u); } } } void dfs2(int u){ vis[u]=1; for(int i=first[u];i;i=e[i].next){ int v=e[i].to; if (!vis[v]){ dfs2(v); // if (u==8 &amp;&amp; v==2) // printf(&quot;%d %d\\n&quot;,u,v); cnt[u]+=cnt[v]; if (cnt[v]) e[i].del=e[i^1].del=1; } } } int deg[maxn]; ll work(){ memset(vis,0,n+1); dfs(1,0); memset(vis,0,n+1); dfs2(1); memset(deg,0,(n+1)*4); for(int i=1;i&lt;=n;i++) if (cnt[i]&gt;=2) return 0; for(int i=2;i&lt;=m;i++) if (!e[i].del) deg[e[i].to]++; // else printf(&quot;%d\\n&quot;,e[i].to); ll ans=1; for(int i=1;i&lt;=n;i++){ // printf(&quot;deg[%d]=%d\\n&quot;,i,deg[i]); ans=(ans*h[deg[i]])%mod; } return ans; } }g; int main(){ init(); h[0]=h[1]=1; for(int i=2;i&lt;=500000;i++) h[i]=(h[i-1]+h[i-2]*(i-1))%mod; int T=readint(); while(T--){ int n=readint(),m=readint(); g.init(n); while(m--){ int u=readint(),v=readint(); g.addedge(u,v); g.addedge(v,u); } printf(&quot;%lld\\n&quot;,g.work()); } } Written with StackEdit.","tags":[{"name":"DP","slug":"DP","permalink":"https://q234rty.top/tags/DP/"},{"name":"计数","slug":"计数","permalink":"https://q234rty.top/tags/计数/"},{"name":"仙人掌","slug":"仙人掌","permalink":"https://q234rty.top/tags/仙人掌/"}]},{"title":"【BZOJ4137】【FJOI2015】火星商店问题","date":"2018-03-03T16:37:41.000Z","path":"2018/03/04/bzoj4137/","text":"线段树套可持久化Trie即可。 如果把一个商品的时间看成横坐标，商店编号看成纵坐标，那么原题可以转化成给定一个坐标平面上的nnn个点，每个点iii有点权viv_iv​i​​，mmm次查询，每次给定xxx，查询一个矩形区域内vi⊕xv_i \\oplus xv​i​​⊕x的最大值。 一个直观的想法是树套树，对xxx轴建线段树，内层使用可持久化Trie支持查询区间vi⊕xv_i \\oplus xv​i​​⊕x的最大值。注意到可持久化Trie要求按顺序插入，那么我们将所有点按纵坐标排序后再插入线段树。询问时找到这个询问对应的所有横坐标区间，分别查询之后取max即可。 看起来这题已经解决了，然而这个做法的空间复杂度是O(nlog2n)O(n \\log^2 n)O(nlog​2​​n)的，无法通过 的空间限制。 那怎么办办呢？注意到我们可以离线，我们预先把所有点和询问挂在它们对应的线段树节点上，这样我们只需要对于每个线段树节点建立一次可持久化Trie就可以了。 这样就解决了这题，时间复杂度O(nlog2n)O(n \\log^2 n)O(nlog​2​​n)，空间复杂度O(nlogn)O(n \\log n)O(nlogn)。 Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=10000020; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(&quot;4137.txt&quot;,&quot;r&quot;,stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=buf[bufpos]==&#39;-&#39;); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } const int maxn=100005; struct trie{ struct node{ int sum,ls,rs; }t[maxn*21]; int cur; void clear(){ cur=ver=0; } int rt[maxn],ver; void insert(int x){ t[++cur]=t[rt[ver]]; int o=rt[++ver]=cur; for(int i=17;i&gt;=0;i--){ t[o].sum++; int &amp;v=(x&gt;&gt;i&amp;1)?t[o].rs:t[o].ls; t[++cur]=t[v]; o=v=cur; } t[o].sum++; } int query(int l,int r,int x){ // printf(&quot;query %d %d %d\\n&quot;,l,r,x); int lo=rt[l-1],ro=rt[r],ans=0; for(int i=17;i&gt;=0;i--){ if (x&gt;&gt;i&amp;1){ if (t[t[ro].ls].sum&gt;t[t[lo].ls].sum) lo=t[lo].ls,ro=t[ro].ls,ans|=1&lt;&lt;i; else lo=t[lo].rs,ro=t[ro].rs; }else{ if (t[t[ro].rs].sum&gt;t[t[lo].rs].sum) lo=t[lo].rs,ro=t[ro].rs,ans|=1&lt;&lt;i; else lo=t[lo].ls,ro=t[ro].ls; } } // puts(&quot;after query&quot;); return ans; } }t; struct query{ int l,r,x,ans; }w[maxn]; struct item{ int p,v; bool operator &lt;(const item&amp; rhs)const{ return p&lt;rhs.p; } }; int ans[maxn]; struct segtree{ int n; vector&lt;int&gt; q[maxn*4]; vector&lt;item&gt; a[maxn*4]; int p; item it; void update(int o,int l,int r){ // printf(&quot;update %d %d %d\\n&quot;,o,l,r); a[o].push_back(it); if (l==r) return; int mid=(l+r)/2; if (p&lt;=mid) update(o*2,l,mid); else update(o*2+1,mid+1,r); } int ql,qr,id; void addq(int o,int l,int r){ if (ql&lt;=l &amp;&amp; qr&gt;=r){ q[o].push_back(id); return; } int mid=(l+r)/2; if (ql&lt;=mid) addq(o*2,l,mid); if (qr&gt;mid) addq(o*2+1,mid+1,r); } void work(int o){ t.clear(); sort(a[o].begin(),a[o].end()); for(int i=0;i&lt;a[o].size();i++) t.insert(a[o][i].v); for(int i=0;i&lt;q[o].size();i++){ query &amp; qwq=w[q[o][i]]; int l=lower_bound(a[o].begin(),a[o].end(),(item){qwq.l,0})-a[o].begin()+1, r=upper_bound(a[o].begin(),a[o].end(),(item){qwq.r,0})-a[o].begin(); if (l&gt;r) continue; qwq.ans=max(qwq.ans,t.query(l,r,qwq.x)); } } void work(){ for(int i=1;i&lt;=4*n;i++) if (q[i].size() &amp;&amp; a[i].size()) work(i); } }s; int main(){ init(); int n=readint(),m=readint(); s.n=m+1; for(int i=1;i&lt;=n;i++) t.insert(readint()); // puts(&quot;WTF&quot;); int day=1,cur=0; for(int o=1;o&lt;=m;o++){ int op=readint(); if (!op){ int p=readint(),v=readint(); s.p=++day,s.it=(item){p,v}; s.update(1,1,s.n); }else{ int l=readint(),r=readint(),x=readint(),d=readint(); // printf(&quot;query %d %d %d %d\\n&quot;,l,r,x,d); w[++cur]=(query){l,r,x,t.query(l,r,x)}; if (!d) continue; s.ql=max(day-d+1,1),s.qr=day,s.id=cur; s.addq(1,1,s.n); } } // puts(&quot;WTF&quot;); s.work(); // printf(&quot;cur=%d\\n&quot;,cur); for(int i=1;i&lt;=cur;i++) printf(&quot;%d\\n&quot;,w[i].ans); } Written with StackEdit.","tags":[{"name":"线段树","slug":"线段树","permalink":"https://q234rty.top/tags/线段树/"},{"name":"Trie","slug":"Trie","permalink":"https://q234rty.top/tags/Trie/"}]},{"title":"【BZOJ4036】【LOJ2127】【HAOI2015】按位或","date":"2018-02-25T05:48:15.000Z","path":"2018/02/25/bzoj4036/","text":"Min-Max容斥+子集和变换即可。 下面不区分普通的数和集合。 设第一次访问第iii位的时间为XiX_iX​i​​，设UUU为{Xi}\\{X_i\\}{X​i​​}，则原题就是求E(max(U))E(max(U))E(max(U))。 直接套用Min-Max容斥可得： E(max(U))=∑S⊆U(−1)∣S∣+1E(min(S)) E(max(U))= \\sum_{S \\subseteq U} (-1)^{|S|+1}E(min(S)) E(max(U))=​S⊆U​∑​​(−1)​∣S∣+1​​E(min(S))考虑计算E(min(S))E(min(S))E(min(S))，设 k=∑T⊆U−SPT k=\\sum_{T \\subseteq {U-S}} P_T k=​T⊆U−S​∑​​P​T​​由等比数列求和公式容易发现 E(min(S))=11−k E(min(S))=\\frac{1}{1-k} E(min(S))=​1−k​​1​​于是子集和变换求出所有的kkk即可，注意特判INF的情况。 Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=30000020; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(&quot;4036.txt&quot;,&quot;r&quot;,stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]=&#39; &#39;; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=buf[bufpos]==&#39;-&#39;); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } double p[1&lt;&lt;20]; char s[101]; int main(){ init(); int n=readint(); for(int i=0;i&lt;(1&lt;&lt;n);i++){ readstr(s); p[i]=strtod(s,0); } for(int i=0;i&lt;n;i++) for(int j=0;j&lt;(1&lt;&lt;n);j++) if (j&gt;&gt;i&amp;1) p[j]+=p[j^(1&lt;&lt;i)]; double ans=0; for(int i=1;i&lt;(1&lt;&lt;n);i++){ double t=1-p[(1&lt;&lt;n)-1-i]; if (t&lt;1e-9) return puts(&quot;INF&quot;),0; t=1/t; if (__builtin_parity(i)) ans+=t; else ans-=t; } printf(&quot;%.10f&quot;,ans); } Written with StackEdit.","tags":[{"name":"容斥原理","slug":"容斥原理","permalink":"https://q234rty.top/tags/容斥原理/"},{"name":"位运算","slug":"位运算","permalink":"https://q234rty.top/tags/位运算/"},{"name":"概率和期望","slug":"概率和期望","permalink":"https://q234rty.top/tags/概率和期望/"}]},{"title":"WC2018旅游记","date":"2018-02-02T21:57:00.000Z","path":"2018/02/03/wc2018/","text":"智障没学上选手前来旅游辣 Day 08:30左右到了雅礼洋湖。 没去PKUWC的人还没来，∑\\sum∑ 不来了，于是沈老师带着我们报道。 先去了一波寝室，发现（果然）没有电。 于是去阅览室颓废，开了一会gzz。 网络好像有点感人？ 遇见了DraZxlNDdt ，好强啊%%%。 去吃午饭，感觉东西还行，但是据说不如绍一当时的自助餐？ 回阅览室，看到了wxh010910 、Created_equal 、krydom 、chouti等一众大佬，还知道了在pkuwc看到的那个妹子是谁。 还看到了晓犇，不过并没有敢上去搭话QAQ。 和wzf2000聊了会hexo 。 据说没有才艺表演？喵喵喵？ 感觉组织不如绍一，虽然我并没有去过去年的冬令营。 晚上开营仪式，没有dzd讲话差评！ 录了一段森林狂想曲233 Day 1早上妹滋滋的IOI2017和Online algorithm。 感觉IOI题很妙啊，虽然并没有听懂。 （感觉找答案的下/上界这个套路很妙啊 Online algorithm后半程掉线。 中午遇到了scarlyw 大佬QAQ 下午myy的TC出题故事。 唯一的感受：钱好多啊（ myy:比如说我要考缓存，那我就出一道题叫做挑战（全场鼓掌 讲题时全程梦游。 晚上去写了gedit 的脚本，还码了下Linux对拍，输出a+b+!(rand()%100) 拍了一分多钟才拍出来。。 Day 2早上吉老师的PA好题选讲，我没有steam账号就不上去凑热闹了 （雾 感觉PA的题好难啊QAQ（然而吉老师还是AK了，恐怖如斯啊 吉老师：中国选手和外国选手的区别就是，中国选手知道五万是可以n方的，外国选手不知道。 下午钟强闲讲NP-Hard问题的近似算法。 感觉这种出成正解不太好吧（不过用来水过一些性质比较弱的题还是资磁的 不过窝并不会写QAQ 晚上LCA的毒瘤营员交流，&quot;每个字都看得懂，连起来就算了&quot;，凡爷表示这是小学/初中内容，Orz Day 3早上“电音之”王逸松的傅里叶变换在OI中的应用，然而我听到一半感觉他讲的东西在OI中很难有应用，就先跑到阅览室颓了。 好像错过了水木道，感觉有点可惜QAQ 中午吃饭的时候和redbag大佬聊了下。 下午猫老师讲圆方树和(动态)动态规划，感觉比普通的点双建树方法优美好多啊，感觉树上动态DP也很厉害？ 猫老师：今天讲课的内容和后天的考试完全没有任何交集（全场鼓掌 然后杜老师讲不平等博弈和Surreal Numbers，感觉没有办法像SG定理一样给出组合游戏的通用解法有点可惜啊，还有好像不小心翻车了？ 晚上试机，然而我发现自己连试机题都不会，没救了QAQ Day 4早上假老师讲图论，听到灭绝树那一段感觉根本听不懂就又鸽了讲课去阅览室颓，据说错过了计数题？ 下午xumingkuan讲IOI2017&amp;计算几何，感觉IOI还是很可听的，然而我对计算几何一窍不通。 晚上鸽了营员交流，在阅览室背板子颓。 Day 5 (Contest)进考场想了一个小时T1，只会 565656 分，看T2感觉不可做，滚去看T3，因为感觉链的情况显然要特判就先写了个链拿 353535 分冷静了下。 然后滚回去做T1，写+拍完已经11:30了，期间发现最小化之后窗口不见了还傻傻地尝试去调，结果没调出来还浪费了一堆时间。。 再看了下T2，感觉 O(3n)O(3^n)O(3​n​​) 好像很蠢？于是写了个冷静了下，发现过不了大样例，然后去调，调出几个傻逼错误，然而还是过不了大样例，感觉整个人都不好了。。 这时我感觉题目里虽然没有提到州一定要连通，但是感觉不连通有些奇怪，于是举手问了猫老师，他告诉我不连通一定合法，于是我发现自己傻了，没有奇点不代表有欧拉回路，于是写了个判连通（然而当时我并没有意识到还有孤立点的情况 于是过了大样例赶快去写T3，写了个随机化过了三个样例就弃疗去检查了。 估分56+50+65=17156+50+65=17156+50+65=171。 出考场发现T2题意是错的，感觉自己运气真好QAQ，心疼被卡题意的选手。 下午回来复评，在机房外等了一个小时终于进去了，发现T3竞然多了555分，实际得分56+50+70=17656+50+70=17656+50+70=176。发现T2有两组数据取max，资磁，虽然感觉还是对被浪费掉时间的选手不公平QAQ 晚上文艺汇演，杜老师&amp;猫老师唱歌好评！松松松上台好评！24OI有节目好评！Menci有参加好评！KDE好评！电音之王lk好评！dt弹幕表白好评！ Day 6早上去省博物馆参观，感觉没什么意思，走马观花了一遍二楼&amp;三楼之后就去一楼颓了，围观旺仔怒抢一血Orz。 下午闭幕式，这样居然都能有Au，还被提前叫去彩排了（然而并没有让我们上台），Orz卡线爷zhouyuyang，Orz初二Au的cnyali_lk，Orz非集训队rk2的初三爷lyx_cjz。发现很多熟悉的dalao都因为被题意杀没有拿到Au，感觉有点可惜，不过非集训队WC的成绩也没什么用吧，祝接下来的比赛好运w 晚上颓到0点。 Day 7滚回绍兴辣 Written with StackEdit.","tags":[{"name":"游记","slug":"游记","permalink":"https://q234rty.top/tags/游记/"}]},{"title":"PKUWC2018没约记","date":"2018-02-02T21:56:46.000Z","path":"2018/02/03/pkuwc2018/","text":"GG辣 Day 1凌晨到了长沙，在一家辣鸡宾馆睡到早上9点。 下午报道，发现是双系统+IOI，好评。 换到了一个离学校近的宾馆，晚上看了前几年的数学题，做好了数学爆蛋的准备。 Day 2 (Contest Day 1)早上开幕式，感觉没什么意义QwQ（据说晓犇来了开幕式然而dt不知道 然后考数学，一眼看到一堆选择题，和往年画风完全不一样。然后有道题目窝算到一半才意识到可以用计算器。。。大题目一题不会打出GG，axs7384 说他写了证伪%%%，有数竞表妹的妹控jzqjzq 好像做出了3道大题%%%。 下午一试。发现我和dt和 jzqjzq 和 redbag 和skylee 和ckr在一个考场，考试之前郁老师进来送点心，吓傻了。 开场看T1，我会505050！冷静一下写掉了，等到拿到505050的时候有几个人过了T2，lyx_cjz过了T1，于是我先去开了T2，想了一会想出了怎么贪心，又想了很久想出了怎么DP，然后写了一发，爆了几发OJ之后过掉了。这时候已经有十几个人过了T1，T3还没有人得分，过了一会SHENZHEBEI 也过了T1，感觉T1应该只要树上动态DP就行了，然后窝并不会就弃疗看了一个小时的榜。出来听SHENZHEBEI 说T1只要线段树合并就行了，感觉自己好蠢。。 于是 50+100+0=15050+100+0=15050+100+0=150 大众分滚粗啦，T3全场无人得分也是厉害。Orz SHENZHEBEI 全场rank1。 晚上吃了奇怪的煲仔饭。 Day 3 (Contest Day 2)早上二试，开场看T1发现不会做，过了半个小时还是不会，这个时候SHENZHEBEI已经过T1了，感觉整个人都不好了。意识模糊写了一个用std::map 记状态的DP，结果T成了505050，这个时候T1已经一片人过了。然后感觉这样下去要跪就先去写了T2的303030分暴力。冷静了一下觉得最大独立集个数应该不多，那么枚举最大独立集之后状态的第二维就是确定的了，可以直接O(2n×n)O(2^n \\times n)O(2​n​​×n)DP，于是写了一发T成了909090，加了个优化就A了。（事实上666个三元环拼上一条独立的边就能卡）然后看T3，想到了Min-Max容斥然而高斯消元不会写，一分都不会，感觉药丸。然后这个时候yukuai26T3拿了202020，然后我想了很久202020怎么拿没想出来，最后尝试拿T2的部分分也没拿到，GG。出来告诉我T3只要把期望当成整数暴力模拟就能202020？？？？？？？？有毒吧。 下午面试，第一次面试的时候一脸懵逼，后来好像稍微好了一点（窝说自己英语还行然后某面试官就让窝用英语自我介绍？？？ 晚上颓颓颓。 Day 4早上讲题+闭幕式，遇见了一个精通Touhou 的大佬。居然有人上台讲斗地主。感觉D2T2 _rqy 的做法好妙啊，还有D2T3标算居然就是Min-Max容斥，不会写高斯消元好亏啊。 然后签约，果然没有无条件一本，感觉自己还是菜啊。Orz SHENZHEBEI 怒签无条件一本，lyx_cjz 已经初三签了一本仍然前来虐场。好像没进面试的选手也有约？ Day 5在宾馆里颓颓颓，为WC冬眠&amp;滚粗埋下了伏笔 感觉dt联赛考挂不能来WC有点可惜啊QAQ Written with StackEdit.","tags":[{"name":"游记","slug":"游记","permalink":"https://q234rty.top/tags/游记/"}]},{"title":"【BZOJ5139】【LOJ2337】【Usaco2017 Dec】Greedy Gift Takers","date":"2018-01-10T17:46:20.000Z","path":"2018/01/11/bzoj5139/","text":"二分答案+排序即可。 容易发现如果一个人拿到过礼物，那么在他前面的人一定也拿到过礼物，于是可以二分答案，考虑怎么判定。 考虑在他前面的人必须都插到他后面，不难发现一个人xxx能拿到礼物当且仅当 ∀i∈[1,x),∑j=1x−1[cj&lt;ci]≥ci+i−n \\forall i \\in [1,x),\\sum_{j=1}^{x-1}[c_j&lt;c_i] \\geq c_i+i-n ∀i∈[1,x),​j=1​∑​x−1​​[c​j​​&lt;c​i​​]≥c​i​​+i−n排序之后扫一遍即可。 使用基数排序，时间复杂度O(nlogn)O(n \\log n)O(nlogn) Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=10000020; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(&quot;5139.txt&quot;,&quot;r&quot;,stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=buf[bufpos]==&#39;-&#39;); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } int n; int a[100003],cnt[100003]; bool check(int x){ for(int i=0;i&lt;=n;i++) cnt[i]=0; for(int i=1;i&lt;x;i++) cnt[a[i]]++; int sum=0; for(int i=0;i&lt;=n;i++){ if (cnt[i] &amp;&amp; sum+n-x&lt;i) return false; sum+=cnt[i]; } return true; } int main(){ init(); n=readint(); for(int i=1;i&lt;=n;i++) a[i]=readint(); int l=1,r=n; while(l&lt;r){ int mid=(l+r+1)/2; if (check(mid)) l=mid; else r=mid-1; } printf(&quot;%d&quot;,n-l); }","tags":[{"name":"二分","slug":"二分","permalink":"https://q234rty.top/tags/二分/"}]},{"title":"NOIP2017滚粗记","date":"2017-11-16T09:46:14.000Z","path":"2017/11/16/noip2017-gg/","text":"AFO辣QwQ Day 0车上借gn4869大佬的耳机听音乐，然而不知道为什么我笔记本网易云音乐的缓存里只有土嗨泉魂音泉。。。 晚上和人赢dt一间房。颓了一会看了看板子，10:10左右睡了。 Day 1发现我下载的闹钟软件的铃声十分假。。。 进场一看文件名，怎么有个math ，好像不太妙。。 打开pdf一看，math怎么是T1啊，感觉有点反常。。 读完题面，咦这题我好像看到过，好像答案是a×b−a−ba \\times b-a-ba×b−a−b ？看了下两个样例发现都是对的，于是我就自信地1min写完了，还没有拍（还好结论是对的不然就完了。。） 看T2，大模拟。。脑补了下各种情况，怕写错所以先判了ERR然后再递归模拟。于是写了很长，9:30过了大样例。 看T3，一眼只会k=0k=0k=0。想了一会发现求个最短路就可以转化为求从111到nnn有多少条路径长度≤k\\leq k≤k ，然后好像对000边拓扑排序然后DP就行了？然后发现这样无法处理-1的情况，然后感觉只要把111到不了和到不了nnn的点删掉，如果还是有环就是-1，于是写写写，过了大样例，手测了几组多组数据的点也没问题，然后卡了下常就没管了。 最后检查了下没发现错误，比赛就结束了。 估分100+100+100=300100+100+100=300100+100+100=300 。 下午看dt和axs7384开文明，又和dt开了会局域网三国杀，某一局dt用于吉因为时间不够没有发动一次技能就GG了，RP--。 晚上感觉自己把袋子忘在了车上，于是吃了KFC。。 10:10左右睡了。 Day 2早上到了车上发现自己的袋子不在这里，GG。 于是作为三无人员进了考场，还被野花毒奶了一口。 看T1，好像就是个并查集？于是很快写完了，过了大样例就没管了。 看T2，一眼不会做，弃疗去写dfs，然后发现大样例能过，vvv全相等的数据过不去，改成了bfs终于过了，这个时候已经10:30了，很慌。 看T3，因为太晚了不敢去想正解，于是先打了O((n+m)×q)O((n+m) \\times q)O((n+m)×q)的暴力，过了大样例，又打了n=1n=1n=1的O((m+q)log(m+q))O((m+q) \\log (m+q))O((m+q)log(m+q))的线段树，和暴力拍了下，11:30左右过了对拍。 最后发现T1要开unsigned long long ，连忙开了。（然而事实上不开也能过）。 估分100+70+70=240100+70+70=240100+70+70=240。 出来发现全世界都会T2T3，感觉自己药丸。 回绍兴之后拿到了程序，去洛谷测了下，发现我D1T3最后卡常的时候有个数组没清爆000了，GG。 Aftermath后来学军数据测出来100+100+50+100+70+70=490100+100+50+100+70+70=490100+100+50+100+70+70=490，感觉好像还有救？ 官方数据100+100+60+100+70+70=500100+100+60+100+70+70=500100+100+60+100+70+70=500 ，D1T3送了我60，居然还能上500500500，感动。。 （D1T3加上数组清空就能过官方数据了，然而那个做法是错的，应该在正反图上各做一遍最短路，然后删掉所有dist(1,u)+dist(u,n)&gt;dist(1,n)+kdist(1,u)+dist(u,n)&gt;dist(1,n)+kdist(1,u)+dist(u,n)&gt;dist(1,n)+k的点） rxdoi、lych_cys、kczno1AK了，跪烂。 zhouyuyang挂了两题依旧570570570，超强！ royms挂成了520520520，然而他比我小一届，还有高数联一等，不知道比我高到哪里去了。 SHENZHEBEID2T2T3都会，结果T2WA成808080 ，T3有个数组没开long longWA成了707070，然而还是比我高了101010分。 dt挂成了455455455 ，好像miaom,wanglichao1121,zx2003也挂了？QAQ 不知道能不能去冬令营啊QAQ","tags":[{"name":"游记","slug":"游记","permalink":"https://q234rty.top/tags/游记/"}]},{"title":"【BZOJ2587】【CEOI2011】Teams","date":"2017-09-23T09:35:54.000Z","path":"2017/09/23/bzoj2587/","text":"动态规划+堆即可。 将aia_ia​i​​从大到小排序，容易发现每一个团队都是一个区间。 考虑暴力DP：设f(i)f(i)f(i)为前iii个人最多分成的团队个数，g(i)g(i)g(i)为前iii个人分成f(i)f(i)f(i)个团队，最大的团队的最少成员数。 易得 考虑用一个链表维护iii处新增的决策点，计算好jjj后把其添加到aj+1+ja_{j+1}+ja​j+1​​+j处的链表中。 注意到g(j)g(j)g(j)相对iii为常数，而 单调递增，那么一个jjj随iii的增加，max(g(j),i−j)\\max(g(j),i-j)max(g(j),i−j)应该先取g(j)g(j)g(j)再取i−ji-ji−j。 考虑再使用一个链表维护iii处有哪些jjj满足g(j)=i−jg(j)=i-jg(j)=i−j，计算好jjj后把其添加到g(j)+jg(j)+jg(j)+j处的链表中。 对于g(j)&lt;i−jg(j)&lt;i-jg(j)&lt;i−j，用一个堆维护f(j)f(j)f(j)的最大值及f(j)f(j)f(j)取最大时g(j)g(j)g(j)的最小值。 对于g(j)≥i−jg(j) \\geq i-jg(j)≥i−j，直接记录f(j)f(j)f(j)的最大值及f(j)f(j)f(j)取最大时jjj的最大值即可。 时间复杂度O(nlogn)O(n \\log n)O(nlogn)。 本题存在时间复杂度O(n)O(n)O(n)的做法，参见lych_cys的题解 。 Code #include &lt;bits/stdc++.h&gt; #include &lt;ext/pb_ds/priority_queue.hpp&gt; using namespace std; typedef long long ll; const int MAXSIZE=30000020; const int INF=0x3f3f3f3f; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(&quot;2587.txt&quot;,&quot;r&quot;,stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=buf[bufpos]==&#39;-&#39;); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } int cnt[1000002],tmp[1000002],a[1000002],b[1000002],f[1000002],g[1000002],lst[1000002]; int nxt[1000002],first[1000002],nxt2[1000002],first2[1000002]; void add(int p,int v){ nxt[v]=first[p]; first[p]=v; } void add2(int p,int v){ nxt2[v]=first2[p]; first2[p]=v; } struct cmp{ bool operator ()(const int &amp;x,const int &amp;y){ return f[x]&lt;f[y] || (f[x]==f[y] &amp;&amp; g[x]&gt;g[y]); } }; typedef __gnu_pbds::priority_queue&lt;int,cmp&gt; heap; heap q; heap::point_iterator it[1000001]; int main(){ init(); int n=readint(); for(int i=1;i&lt;=n;i++) tmp[i]=readint(),cnt[tmp[i]]++; for(int i=n;i;i--) cnt[i]+=cnt[i+1]; for(int i=1;i&lt;=n;i++) b[cnt[tmp[i]]]=i,a[cnt[tmp[i]]--]=tmp[i]; int now=0; //for(int i=1;i&lt;=n;i++) //printf(&quot;%d &quot;,a[i]); for(int i=1;i&lt;=n;i++){ //g[j]+j&lt;=i //puts(&quot;WTF&quot;); for(int to=first2[i];to;to=nxt2[to]){ if (g[to]+to&lt;i){ if (f[to]&gt;=f[now]) now=to; }else { //printf(&quot;adding %d\\n&quot;,to); it[to]=q.push(to); } } //puts(&quot;233&quot;); for(int j=first[i];j;j=nxt[j]){ if (j+a[j+1]&gt;i) continue; //printf(&quot;%d\\n&quot;,j); q.erase(it[j]); if (f[j]&gt;f[now] || (f[j]==f[now] &amp;&amp; j&gt;now)) now=j; } //puts(&quot;tat&quot;); if (q.empty()){ if (!now &amp;&amp; i&lt;a[1]){ g[i]=INF; continue; } f[i]=f[now]+1; g[i]=i-now; lst[i]=now; }else{ int x=q.top(); if (f[x]==f[now]){ f[i]=f[x]+1; if (i-now&lt;g[x]) g[i]=i-now,lst[i]=now; else g[i]=g[x],lst[i]=x; }else if (f[x]&lt;f[now]) f[i]=f[now]+1,g[i]=i-now,lst[i]=now; else f[i]=f[x]+1,g[i]=g[x],lst[i]=x; } //puts(&quot;qwq&quot;); //printf(&quot;f[%d]=%d\\n&quot;,i,f[i]); if (g[i]+i&lt;=n) add(g[i]+i,i); if (i&lt;n &amp;&amp; i+a[i+1]&lt;=n) add2(i+a[i+1],i); } printf(&quot;%d\\n&quot;,f[n]); for(int i=n;i;){ int w=lst[i]; printf(&quot;%d &quot;,i-w); while(i&gt;w){ printf(&quot;%d &quot;,b[i]); i--; } putchar(&#39;\\n&#39;); } }","tags":[{"name":"DP","slug":"DP","permalink":"https://q234rty.top/tags/DP/"},{"name":"堆","slug":"堆","permalink":"https://q234rty.top/tags/堆/"}]},{"title":"【BZOJ1827】【Vijos1487】【Usaco2010 Mar】奶牛聚会","date":"2017-09-16T13:54:58.000Z","path":"2017/09/16/bzoj1827/","text":"树形DP即可。 我们定义f(u)=∑v in u&#x27;s subtreecv×dis(u,v)\\displaystyle f(u)=\\sum_{v \\text{ in }u\\text{&#x27;s subtree} } c_v \\times dis(u,v)f(u)=​v in u&#x27;s subtree​∑​​c​v​​×dis(u,v)，g(u)=∑v isn&#x27;t in u&#x27;s subtreecv×dis(u,v)\\displaystyle g(u)=\\sum_{v \\text{ isn&#x27;t in }u\\text{&#x27;s subtree} } c_v \\times dis(u,v)g(u)=​v isn&#x27;t in u&#x27;s subtree​∑​​c​v​​×dis(u,v)。 那么 ans=min1≤u≤nf(u)+g(u)\\displaystyle ans=\\min_{1\\le u \\le n}f(u)+g(u)ans=​1≤u≤n​min​​f(u)+g(u)。 接下来考虑怎么求fff和ggg。 容易发现f(u)=∑v is u&#x27;s childf(v)+w(u,v)∗sz(v)\\displaystyle f(u)=\\sum_{v\\text{ is }u\\text{&#x27;s child}}f(v)+w(u,v)*sz(v)f(u)=​v is u&#x27;s child​∑​​f(v)+w(u,v)∗sz(v)，其中sz(u)=∑v in u&#x27;s subtreecv\\displaystyle sz(u)=\\sum_{v \\text{ in }u\\text{&#x27;s subtree} } c_v sz(u)=​v in u&#x27;s subtree​∑​​c​v​​。 那么g(u)g(u)g(u)怎么求呢？考虑从g(fa(u))+f(fa(u))g(fa(u))+f(fa(u))g(fa(u))+f(fa(u))里减去uuu的子树的贡献，设sum=∑u=1ncu\\displaystyle sum=\\sum_{u=1}^{n} c_usum=​u=1​∑​n​​c​u​​，我们有： g(u)=f(fa(u))+g(fa(u))−f(u)−sz(u)∗w(u,fa(u))+(sum−sz(u))×w(u,fa(u))g(u)=f(fa(u))+g(fa(u))-f(u)-sz(u)*w(u,fa(u))+(sum-sz(u))\\times w(u,fa(u))g(u)=f(fa(u))+g(fa(u))−f(u)−sz(u)∗w(u,fa(u))+(sum−sz(u))×w(u,fa(u))于是两遍dfs计算szszsz、fff和ggg就好。 Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=30000020; const ll INF=0x3f3f3f3f3f3f3f3fLL; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(&quot;1827.txt&quot;,&quot;r&quot;,stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=buf[bufpos]==&#39;-&#39;); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } const int maxn=100001; struct graph{ ll sum; int n,m; struct edge{ int to,next,cost; }e[maxn*2]; int first[maxn]; void addedge(int from,int to,int cost){ e[++m]=(edge){to,first[from],cost}; first[from]=m; } bool vis[maxn]; ll c[maxn],sz[maxn]; ll f[maxn],g[maxn]; void dfs(int u){ sz[u]=c[u]; vis[u]=1; for(int i=first[u];i;i=e[i].next){ int v=e[i].to; if (vis[v]) continue; dfs(v); sz[u]+=sz[v]; f[u]+=f[v]+sz[v]*e[i].cost; } } void dfs2(int u){ vis[u]=1; //printf(&quot;%d\\n&quot;,u); for(int i=first[u];i;i=e[i].next){ int v=e[i].to; //printf(&quot;%d\\n&quot;,v); if (vis[v]) continue; g[v]=g[u]+f[u]-f[v]-sz[v]*e[i].cost+(sum-sz[v])*e[i].cost; dfs2(v); } } ll work(int n){ for(int i=1;i&lt;=n;i++) sum+=c[i]; dfs(1); memset(vis,0,sizeof(vis)); dfs2(1); ll ans=INF; for(int i=1;i&lt;=n;i++){ //printf(&quot;%lld %lld %lld\\n&quot;,sz[i],f[i],g[i]); ans=min(ans,f[i]+g[i]); } return ans; } }g; int main(){ init(); int n=readint(); for(int i=1;i&lt;=n;i++) g.c[i]=readint(); for(int i=1;i&lt;n;i++){ int x=readint(),y=readint(),z=readint(); g.addedge(x,y,z); g.addedge(y,x,z); } printf(&quot;%lld&quot;,g.work(n)); }","tags":[{"name":"DP","slug":"DP","permalink":"https://q234rty.top/tags/DP/"}]},{"title":"【LOJ2254】【SNOI2017】一个简单的询问","date":"2017-08-02T07:32:28.000Z","path":"2017/08/02/loj2254/","text":"莫队算法即可。 本题粗看似乎无从下手，考虑将一个询问拆成多个前缀询问。 设f(x,y)=ans(1,x,1,y)f(x,y)=ans(1,x,1,y)f(x,y)=ans(1,x,1,y),g(x,y)=get(1,x,y)g(x,y)=get(1,x,y)g(x,y)=get(1,x,y),我们有 ans(l1,r1,l2,r2)=∑x=0∞(g(r1,x)−g(l1−1,x))×(g(r2,x)−g(l2−1,x))=∑x=0∞g(r1,x)×g(r2,x)−g(r1,x)×g(l2−1,x)−g(l1−1,x)×g(r2,x)+g(l1−1,x)×g(l2−1,x)=f(r1,r2)−f(r1,l2−1)−f(l1−1,r2)+f(l1−1,l2−1) \\begin{aligned} ans(l1,r1,l2,r2) &amp; =\\sum_{x=0}^{\\infty}(g(r1,x)-g(l1-1,x))\\times (g(r2,x)-g(l2-1,x))\\\\ &amp; =\\sum_{x=0}^{\\infty}g(r1,x)\\times g(r2,x)-g(r1,x)\\times g(l2-1,x)\\\\ &amp; -g(l1-1,x)\\times g(r2,x)+g(l1-1,x)\\times g(l2-1,x)\\\\ &amp; =f(r1,r2)-f(r1,l2-1)-f(l1-1,r2)+f(l1-1,l2-1) \\end{aligned} ​ans(l1,r1,l2,r2)​​​​​​=​x=0​∑​∞​​(g(r1,x)−g(l1−1,x))×(g(r2,x)−g(l2−1,x))​=​x=0​∑​∞​​g(r1,x)×g(r2,x)−g(r1,x)×g(l2−1,x)​−g(l1−1,x)×g(r2,x)+g(l1−1,x)×g(l2−1,x)​=f(r1,r2)−f(r1,l2−1)−f(l1−1,r2)+f(l1−1,l2−1)​​于是用莫队计算fff即可。 用两个数组分别维护两个前缀中每个数的出现次数，增删数时可以O(1)O(1)O(1)更新答案。 时间复杂度O(nn)O(n \\sqrt n)O(n√​n​​​) 。 Code #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int MAXSIZE=10000020; int bufpos; char buf[MAXSIZE]; #define NEG 0 void init(){ #ifdef LOCAL freopen(&quot;2254.txt&quot;,&quot;r&quot;,stdin); #endif buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } #if NEG int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=buf[bufpos]==&#39;-&#39;); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } #else int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } #endif char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } ll ans[50001],now; int a[50001],cnt[2][50001],pl[50001]; struct query{ int p,sgn,l1,l2; bool operator &lt;(const query&amp; rhs)const{ return pl[l1]!=pl[rhs.l1]?pl[l1]&lt;pl[rhs.l1]:l2&lt;rhs.l2; } }q[200001]; void update(int p,int v,int sgn){ now+=sgn*cnt[p^1][v]; cnt[p][v]+=sgn; } int main(){ init(); int n=readint(),cur=0; for(int i=1;i&lt;=n;i++) a[i]=readint(); int m=readint(); for(int i=1;i&lt;=m;i++){ int l1=readint()-1,r1=readint(),l2=readint()-1,r2=readint(); if (l1) q[++cur]=(query){i,-1,l1,r2}; if (l2) q[++cur]=(query){i,-1,l2,r1}; if (l1 &amp;&amp; l2) q[++cur]=(query){i,1,l1,l2}; q[++cur]=(query){i,1,r1,r2}; } int sz=sqrt(n)+0.5; for(int i=1;i&lt;=n;i++) pl[i]=(i-1)/sz+1; sort(q+1,q+cur+1); int l1=0,l2=0; for(int i=1;i&lt;=cur;i++){ while(l1&lt;q[i].l1) update(0,a[++l1],1); while(l1&gt;q[i].l1) update(0,a[l1--],-1); while(l2&lt;q[i].l2) update(1,a[++l2],1); while(l2&gt;q[i].l2) update(1,a[l2--],-1); ans[q[i].p]+=now*q[i].sgn; } for(int i=1;i&lt;=m;i++) printf(&quot;%lld\\n&quot;,ans[i]); }","tags":[{"name":"莫队","slug":"莫队","permalink":"https://q234rty.top/tags/莫队/"},{"name":"分块","slug":"分块","permalink":"https://q234rty.top/tags/分块/"}]},{"title":"【BZOJ2482】【SPOJ1557】GSS2","date":"2017-04-29T01:47:11.000Z","path":"2017/04/29/bzoj2482/","text":"离线处理+线段树即可。 离线，将所有询问按右端点从小到大排序，从小到大枚举答案区间的右端点iii，维护sum[j]sum[j]sum[j]表示[j,i][j,i][j,i]中不同值的和，每次把sum[lst[i]+1..i]sum[lst[i]+1..i]sum[lst[i]+1..i]加上a[i]a[i]a[i],不难发现询问[l,i][l,i][l,i]的答案是sum[l..i]sum[l..i]sum[l..i]中所有元素的历史最大值的最大值。 于是问题就变成了：维护一个数据结构，支持区间加一个数，询问区间历史最大值的最大值。 线段树维护当前最大值，历史最大值。标记当前需要加上的xxx，历史最大的xxx。注意标记有时间顺序，所以需要pushdown 。 Code #include &lt;bits/stdc++.h&gt; using namespace std; const int MAXSIZE=30000020; int bufpos; char buf[MAXSIZE]; void init(){ buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=(buf[bufpos]==&#39;-&#39;))?1:0; for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } int readstr(char* s){ int cur=0; for(;isspace(buf[bufpos]);bufpos++); for(;!isspace(buf[bufpos]);bufpos++) s[cur++]=buf[bufpos]; s[cur]=&#39;\\0&#39;; return cur; } typedef long long ll; const ll INF=0x3f3f3f3f3f3f3f3fLL; struct tag{ ll add,curadd; tag(ll x=0){ add=x; curadd=max(x,0LL); } tag&amp; operator +=(const tag&amp; rhs){ curadd=max(curadd,add+rhs.curadd); add+=rhs.add; return *this; } }; struct atom{ ll mmax,curmax; atom(){ mmax=curmax=0; } atom(ll mmax,ll curmax){ this-&gt;mmax=mmax,this-&gt;curmax=curmax; } atom operator +(const atom&amp; rhs)const{ return atom(max(mmax,rhs.mmax),max(curmax,rhs.curmax)); } atom&amp; operator +=(const atom&amp; rhs){ return *this=*this+rhs; } atom operator +(const tag&amp; x)const{ return atom(mmax+x.add,max(curmax,mmax+x.curadd)); } atom&amp; operator +=(const tag&amp; x){ return *this=*this+x; } }; const int maxn=100001; struct segtree{ static const int maxt=maxn*4; atom t[maxt]; tag v[maxt]; int n; void init(int n){ this-&gt;n=n; } void pushdown(int o){ v[o*2]+=v[o]; t[o*2]+=v[o]; v[o*2+1]+=v[o]; t[o*2+1]+=v[o]; v[o]=tag(); } int ul,ur,uv; void update(int o,int l,int r){ if (ul&lt;=l &amp;&amp; ur&gt;=r){ t[o]+=uv; v[o]+=uv; return; } pushdown(o); int mid=(l+r)/2; if (ul&lt;=mid) update(o*2,l,mid); if (ur&gt;mid) update(o*2+1,mid+1,r); t[o]=t[o*2]+t[o*2+1]; } int ql,qr; atom query(int o,int l,int r){ if (ql&lt;=l &amp;&amp; qr&gt;=r) return t[o]; int mid=(l+r)/2; atom res; res.mmax=-INF; if (ql&lt;=mid) res+=query(o*2,l,mid); if (qr&gt;mid) res+=query(o*2+1,mid+1,r); return res+v[o]; } }t; struct query{ int p,l,r; bool operator &lt;(const query&amp; rhs)const{ return r&lt;rhs.r; } }q[maxn]; const int delta=100000; int now[200003]; int a[maxn]; bool vis[200003]; int lst[maxn]; ll ans[maxn]; int main(){ init(); int n=readint(); t.init(n); for(int i=1;i&lt;=n;i++){ a[i]=readint(); lst[i]=now[a[i]+delta]; now[a[i]+delta]=i; } int m=readint(); for(int i=1;i&lt;=m;i++) q[i].p=i,q[i].l=readint(),q[i].r=readint(); sort(q+1,q+m+1); int now=1; for(int i=1;i&lt;=m;i++){ while(now&lt;=q[i].r){ t.ul=lst[now]+1; t.ur=now; t.uv=a[now]; t.update(1,1,n); now++; } t.ql=q[i].l,t.qr=q[i].r; ans[q[i].p]=t.query(1,1,n).curmax; } for(int i=1;i&lt;=m;i++) printf(&quot;%lld\\n&quot;,ans[i]); }","tags":[{"name":"离线","slug":"离线","permalink":"https://q234rty.top/tags/离线/"},{"name":"线段树","slug":"线段树","permalink":"https://q234rty.top/tags/线段树/"}]},{"title":"【UOJ291】【ZJOI2017】树状数组","date":"2017-03-28T03:36:12.000Z","path":"2017/03/28/uoj291/","text":"cdq分治+线段树即可。 题解请戳InvUsr的博客 Code #include &lt;bits/stdc++.h&gt; using namespace std; const int MAXSIZE=30000020; const int maxn=100001; int bufpos; char buf[MAXSIZE]; void init(){ #ifdef LOCAL freopen(&quot;291.txt&quot;,&quot;r&quot;,stdin); #endif // LOCAL buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } typedef long long ll; const ll mod=998244353; ll power(ll x,ll y){ ll t=x,res=1; while(y){ if (y%2) (res*=t)%=mod; (t*=t)%=mod; y/=2; } return res; } ll pls(ll x,ll y){ return (x*(1-y)+(1-x)*y)%mod; } struct atom{ ll prob1,prob2; atom(){ prob1=prob2=0; } atom(ll prob1,ll prob2):prob1(prob1),prob2(prob2){} atom operator +(const atom&amp; rhs)const{ return atom(pls(prob1,rhs.prob1),pls(prob2,rhs.prob2)); } atom&amp; operator +=(const atom&amp; rhs){ return *this=(*this)+rhs; } }; struct segtree{ int n; atom t[maxn*4]; int w[maxn*20]; void init(int n){ this-&gt;n=n; } int cur; void clear(){ for(int i=1;i&lt;=cur;i++) t[w[i]].prob1=t[w[i]].prob2=0; cur=0; } int p; atom v; void update(int o,int l,int r){ if (l==r){ t[w[++cur]=o]+=v; return; } int mid=(l+r)/2; if (p&lt;=mid) update(o*2,l,mid); else update(o*2+1,mid+1,r); t[w[++cur]=o]=t[o*2]+t[o*2+1]; } void update(int p,atom&amp; v){ this-&gt;p=p; this-&gt;v=v; update(1,1,n); } int ql,qr; atom query(int o,int l,int r){ if (ql&lt;=l &amp;&amp; qr&gt;=r){ //printf(&quot;on %d %d %lld\\n&quot;,l,r,t[o].prob1); return t[o]; } int mid=(l+r)/2; atom res; if (ql&lt;=mid) res+=query(o*2,l,mid); if (qr&gt;mid) res+=query(o*2+1,mid+1,r); return res; } atom query(int l,int r){ ql=l,qr=r; return query(1,1,n); } }t; struct query{ int typ,p,l,r; atom w; }a[maxn],b[maxn]; bool comp1(const query&amp; x,const query&amp; y){ return x.l==y.l?x.typ&lt;y.typ:x.l&lt;y.l; } bool comp2(const query&amp; x,const query&amp; y){ return x.r==y.r?x.typ&lt;y.typ:x.r&gt;y.r; } ll ans[maxn]; int n; void cdq(int l,int r){ if (l==r) return; int mid=(l+r)/2; cdq(l,mid); cdq(mid+1,r); int cur=0; for(int i=l;i&lt;=mid;i++) if (a[i].typ==1) b[++cur]=a[i]; for(int i=mid+1;i&lt;=r;i++) if (a[i].typ==2) b[++cur]=a[i]; t.clear(); sort(b+1,b+cur+1,comp1); for(int i=1;i&lt;=cur;i++){ if (!b[i].l) continue; if (b[i].typ==1){ //printf(&quot;%d %d %lld\\n&quot;,b[i].l,b[i].r,b[i].w.prob1); t.update(b[i].r,b[i].w); }else{ atom x=t.query(b[i].l,b[i].r-1),y=t.query(b[i].r,n); //if (b[i].l==1 &amp;&amp; b[i].r==5) //printf(&quot;qaq=%lld\\n&quot;,x.prob1); ans[b[i].p]=pls(ans[b[i].p],pls(x.prob1,y.prob2)); } } sort(b+1,b+cur+1,comp2); t.clear(); for(int i=1;i&lt;=cur;i++){ if (b[i].typ==1) t.update(b[i].l,b[i].w); else ans[b[i].p]=pls(ans[b[i].p],t.query(b[i].l+1,b[i].r).prob1); } } bool flag[maxn]; bool isq[maxn]; int main(){ init(); n=readint(); int m=readint(); t.init(n); for(int i=1;i&lt;=m;i++){ a[i].typ=readint(),a[i].l=readint(),a[i].r=readint(); a[i].p=i; if (a[i].typ==1){ ll t=power(a[i].r-a[i].l+1,mod-2); a[i].w=atom(t,t*2%mod); flag[i]=!flag[i-1]; }else a[i].l--,flag[i]=flag[i-1],isq[i]=true; } //puts(&quot;WTF&quot;); cdq(1,m); for(int i=1;i&lt;=m;i++){ if (!isq[i]) continue; //printf(&quot;%lld\\n&quot;,ans[i]); if (a[i].l || !flag[i]) ans[i]=(1-ans[i])%mod; printf(&quot;%lld\\n&quot;,(ans[i]+mod)%mod); } }","tags":[{"name":"线段树","slug":"线段树","permalink":"https://q234rty.top/tags/线段树/"},{"name":"cdq分治","slug":"cdq分治","permalink":"https://q234rty.top/tags/cdq分治/"}]},{"title":"【UOJ25】【IOI2014】Wall","date":"2017-03-28T02:32:49.000Z","path":"2017/03/28/uoj25/","text":"线段树即可。 We need to build a wall!（雾） 标记：(l,r)(l,r)(l,r)表示将小于lll的数变为lll，大于rrr的数变为rrr，其余的数不变。显然对xxx取min就是(0,x)(0,x)(0,x)，对xxx取max就是(x,INF)(x,INF)(x,INF)。 其中(l1,r1)(l1,r1)(l1,r1)先执行，(l2,r2)(l2,r2)(l2,r2)后执行。 直接上线段树，最后dfs一遍算出答案即可。 Code #include &lt;bits/stdc++.h&gt; using namespace std; const int INF=100000; struct tag{ int l,r; tag():l(0),r(INF){} tag(int x):l(x),r(x){} tag(int l,int r):l(l),r(r){} tag operator +(const tag&amp; rhs)const{ if (r&lt;rhs.l) return rhs.l; if (rhs.r&lt;l) return rhs.r; return tag(max(l,rhs.l),min(r,rhs.r)); } tag&amp; operator +=(const tag&amp; rhs){ return *this=*this+rhs; } }; const int maxn=2000001; struct segtree{ int n; tag tagv[maxn*4]; void build(int o,int l,int r){ if (l==r){ tagv[o]=0; return; } int mid=(l+r)/2; build(o*2,l,mid); build(o*2+1,mid+1,r); } void init(int n){ this-&gt;n=n; build(1,0,n-1); } void pushdown(int o){ tagv[o*2]+=tagv[o]; tagv[o*2+1]+=tagv[o]; tagv[o]=tag(); } int ul,ur; tag v; void update(int o,int l,int r){ if (ul&lt;=l &amp;&amp; ur&gt;=r){ tagv[o]+=v; return; } int mid=(l+r)/2; pushdown(o); if (ul&lt;=mid) update(o*2,l,mid); if (ur&gt;mid) update(o*2+1,mid+1,r); } void update(int op,int l,int r,int h){ ul=l,ur=r; v=op==1?tag(h,INF):tag(0,h); update(1,0,n-1); } int* ans; void dfs(int o,int l,int r,tag t=tag()){ if (l==r){ ans[l]=(tagv[o]+t).l; return; } int mid=(l+r)/2; tag w=tagv[o]+t; dfs(o*2,l,mid,w); dfs(o*2+1,mid+1,r,w); } void query(int *ans){ this-&gt;ans=ans; dfs(1,0,n-1); } }t; void buildWall(int n,int m,int *op,int *l,int *r,int *h,int *ans){ t.init(n); for(int i=0;i&lt;m;i++) t.update(op[i],l[i],r[i],h[i]); t.query(ans); }","tags":[{"name":"线段树","slug":"线段树","permalink":"https://q234rty.top/tags/线段树/"}]},{"title":"ZJOI2017 Round1游记","date":"2017-03-24T10:15:29.000Z","path":"2017/03/24/zjoi2017-round1/","text":"滚粗啦 Day 0下午乘车到了温州，车上一群大爷打三国杀，lxy1v3成功杀死对面首领逆转。。 晚上点了批萨，然后发现套餐里的饮品是咖啡，于是就浪费了两杯咖啡。。 Day 1感觉宾馆早餐十分不兹磁。。 早上猪猪侠讲搜索，然而我听了之后还是不会DLX。 下午先是613讲STL，似乎是我听懂最多的一课，然后Scape讲杂题，几乎全程掉线。 Day 2早上syc讲AGC，全程掉线。orz 比利大军。 中午发现最贵的荤菜标价也只有4.50元，然而我们的饭票面值20元，却只有两荤两素。。 下午敦敦敦讲杂题，感觉比上午简单了一点，然而掉线的次数还是很多。 花絮：敦敦敦讲了一道我们考过的题，然后roylyx找到了代码，于是： 晚上群里一群人奶范老师(Aw(u)D(i))，我看了会板子就睡了。 Day 3考试。 打开题面看到“九条可怜”，想起前两天敦敦敦和猪猪侠讲到吉利的题时都提醒我们注意他的出题格式，瞬间意识到了出题人是谁。 看T1，发现后面有链的20分，于是就推了下DP式子，然后发现答案是2n−22^{n-2}2​n−2​​。。然后发现自己连树的情况都不会就弃疗了。 看T2，没有想法，于是去看T3，当时把 18×50018 \\times 50018×500 算成了 900009000090000 于是以为暴力也需要卡常，于是滚回去看T2。 然后发现似乎只要预处理一下每个ADD对哪些FIND有影响就可以DP了？于是就写了个，过了小样例，然而当时我不知道有大样例，于是写了个暴力对拍，一组就拍出错了，然后意识到不能单独考虑lll和rrr ，要一起考虑，于是改了一下，发现有大样例就测了一下，过了，然而复杂度变成了O(n3)O(n^3)O(n​3​​) ，对着程序看了一会才想出怎么优化成O(n2)O(n^2)O(n​2​​)，然后大样例还是过的，就不管了。。 最后写了T3的bitset暴力，检查了一下，比赛就结束了。 估分20+50+10=80。 成绩出来发现T1多了10分，感觉是有其它点答案也都是2n−22^{n-2}2​n−2​​ ? 梁大会T2正解，然而似乎因为算出来会爆空间就没去写，后来发现空间开小点是能过的？好像高二有些人也考挂了，希望二试能翻盘吧。感觉自己这一次败了很多RP，宁波市赛要滚粗啦。 就以幕后黑手的两句话来总结吧。","tags":[{"name":"游记","slug":"游记","permalink":"https://q234rty.top/tags/游记/"}]},{"title":"【BZOJ3236】【AHOI2013】作业","date":"2017-02-17T15:22:49.000Z","path":"2017/02/17/bzoj3236/","text":"莫队算法即可。 注意到修改有O((m+n)n)O((m+n)\\sqrt n)O((m+n)√​n​​​)次，而询问只有O(m)O(m)O(m)次，考虑用一个询问O(n)O(\\sqrt n)O(√​n​​​)，修改O(1)O(1)O(1)的权值分块来维护当前书的集合，总时间复杂度O((m+n)n)O((m+n)\\sqrt n)O((m+n)√​n​​​)。 Code #include &lt;cctype&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; const int MAXSIZE=40000020; int bufpos; char buf[MAXSIZE]; void init(){ buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } struct block{ int n,sz,num; int sum[321],o[321]; int cnt[100001]; int w[100001]; int st[321]; void init(int n){ sz=sqrt(n)+0.5; num=(n-1)/sz+1; st[1]=1; for(int i=1;i&lt;=n;i++) w[i]=(i-1)/sz+1; for(int i=2;i&lt;=num;i++) st[i]=st[i-1]+sz; st[num+1]=n+1; } void update(int x,int sgn){ if (!cnt[x]) o[w[x]]++; cnt[x]+=sgn; sum[w[x]]+=sgn; if (!cnt[x]) o[w[x]]--; } pair&lt;int,int&gt; query(int a,int b){ int res1=0,res2=0; if (w[a]==w[b]){ for(int i=a;i&lt;=b;i++) res1+=cnt[i],res2+=!!cnt[i]; return make_pair(res1,res2); } for(int i=w[a]+1;i&lt;w[b];i++) res1+=sum[i],res2+=o[i]; for(int i=a;i&lt;st[w[a]+1];i++) res1+=cnt[i],res2+=!!cnt[i]; for(int i=st[w[b]];i&lt;=b;i++) res1+=cnt[i],res2+=!!cnt[i]; return make_pair(res1,res2); } }t; int sz; struct query{ int p,l,r,a,b; bool operator &lt;(const query&amp; rhs)const{ return l/sz!=rhs.l/sz?l/sz&lt;rhs.l/sz:r&lt;rhs.r; } }q[1000001]; int a[100001]; pair&lt;int,int&gt; ans[1000001]; int main(){ init(); int n=readint(),m=readint(); sz=sqrt(n)+0.5; for(int i=1;i&lt;=n;i++) a[i]=readint(); for(int i=1;i&lt;=m;i++) q[i].p=i,q[i].l=readint(),q[i].r=readint(),q[i].a=readint(),q[i].b=readint(); sort(q+1,q+m+1); int l=1,r=0; t.init(n); for(int i=1;i&lt;=m;i++){ while(l&lt;q[i].l) t.update(a[l++],-1); while(r&lt;q[i].r) t.update(a[++r],1); while(l&gt;q[i].l) t.update(a[--l],1); while(r&gt;q[i].r) t.update(a[r--],-1); ans[q[i].p]=t.query(q[i].a,q[i].b); } for(int i=1;i&lt;=m;i++) printf(&quot;%d %d\\n&quot;,ans[i].first,ans[i].second); }","tags":[{"name":"莫队","slug":"莫队","permalink":"https://q234rty.top/tags/莫队/"},{"name":"分块","slug":"分块","permalink":"https://q234rty.top/tags/分块/"}]},{"title":"【BZOJ3048】【Usaco2013 Jan】Cow Lineup","date":"2016-12-31T10:53:47.000Z","path":"2016/12/31/bzoj3048/","text":"线段树即可。 首先，定义nxt[i]nxt[i]nxt[i]为和a[i]a[i]a[i]相同的下一个数的位置，lst[i]lst[i]lst[i]为和a[i]a[i]a[i]相同的上一个数的位置。 从大到小枚举删数后的最长完美序列在原序列中的右端点rrr，同时用线段树维护每个位置iii是否对不同数的个数有贡献（也就是nxt[i]nxt[i]nxt[i]是否大于rrr），不难发现rrr左移之后只有lst[r]lst[r]lst[r]变得有了贡献。在线段树上寻找一个iii使得rank(r)−rank(i)&gt;k+1rank(r)-rank(i)&gt;k+1rank(r)−rank(i)&gt;k+1且iii最大，最后数一下[i+1,r][i+1,r][i+1,r]中满足a[p]=a[r]a[p]=a[r]a[p]=a[r]的ppp有多少个来更新答案。 时间复杂度O(nlogn)O(n \\log n)O(nlogn)，空间复杂度O(n)O(n)O(n)。 Code #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; using namespace std; const int maxn=100001; struct segtree{ int sumv[maxn*4]; int n; int kth(int k){ int o=1,l=1,r=n; while(l&lt;r){ int mid=(l+r)/2; if(k&lt;=sumv[o*2]) o*=2,r=mid; else k-=sumv[o*2],o=o*2+1,l=mid+1; } return l; } int ql,qr; int query(int o,int l,int r){ if (ql&lt;=l &amp;&amp; qr&gt;=r) return sumv[o]; int mid=(l+r)/2; int ans=0; if (ql&lt;=mid) ans+=query(o*2,l,mid); if (qr&gt;mid) ans+=query(o*2+1,mid+1,r); return ans; } int rank(int x){ ql=1,qr=x; return query(1,1,n); } int p,v; void add(int o,int l,int r){ if (l==r){ sumv[o]+=v; return; } int mid=(l+r)/2; if (p&lt;=mid) add(o*2,l,mid); else add(o*2+1,mid+1,r); sumv[o]+=v; } void add(int p,int v){ this-&gt;p=p; this-&gt;v=v; add(1,1,n); } }t; int a[maxn],lst[maxn],nxt[maxn]; int now[maxn]; int nums[maxn],cur; pair&lt;int,int&gt; x[maxn]; int main(){ int n,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); k++; t.n=n; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,a+i),nums[i]=a[i]; cur=n; sort(nums+1,nums+cur+1); cur=unique(nums+1,nums+cur+1)-nums-1; for(int i=1;i&lt;=n;i++) a[i]=lower_bound(nums+1,nums+cur+1,a[i])-nums; for(int i=1;i&lt;=n;i++) x[i].first=a[i],x[i].second=i; sort(x+1,x+n+1); for(int i=1;i&lt;=n;i++){ lst[i]=now[a[i]]; nxt[now[a[i]]]=i; now[a[i]]=i; } for(int i=1;i&lt;=n;i++) if (!nxt[i]){ //printf(&quot;%d\\n&quot;,i); t.add(i,1); } int ans=0; for(int i=n;i&gt;=1;i--){ int q=t.rank(i),y=q&gt;k?t.kth(q-k):0; int r=upper_bound(x+1,x+n+1,make_pair(a[i],i))-x-1,l=upper_bound(x+1,x+n+1,make_pair(a[i],y))-x-1; //printf(&quot;i=%d q=%d y=%d l=%d r=%d\\n&quot;,i,q,y,l,r); ans=max(ans,r-l); if (lst[i]) t.add(lst[i],1); } printf(&quot;%d&quot;,ans); }","tags":[{"name":"线段树","slug":"线段树","permalink":"https://q234rty.top/tags/线段树/"}]},{"title":"【BZOJ3994】【Vijos1949】【SDOI2015】约数个数和","date":"2016-08-03T04:00:00.000Z","path":"2016/08/03/bzoj3994/","text":"莫比乌斯反演即可。 由于NMNMNM的约数一定可以写成pMq(p∣N,q∣M)\\frac{pM} {q}(p \\mid N ,q \\mid M)​q​​pM​​(p∣N,q∣M)的形式,我们有： d(NM)=∑p∣N∑q∣M[gcd(p,q)=1] d(NM)=\\sum_{p\\mid N}\\sum_{q\\mid M}[\\gcd(p,q)=1] d(NM)=​p∣N​∑​​​q∣M​∑​​[gcd(p,q)=1]代入原式： ∑i=1N∑j=1Md(ij)=∑i=1N∑j=1M∑p∣i∑q∣j[gcd(p,q)=1]=∑i=1N∑j=1M⌊Ni⌋⌊Mj⌋[gcd(i,j)=1]=∑i=1N∑j=1M⌊Ni⌋⌊Mj⌋∑d∣gcd(i,j)μ(d)=∑d=1Nμ(d)∑i=1⌊Nd⌋∑j=1⌊Md⌋⌊Nid⌋⌊Mjd⌋=∑d=1Nμ(d)∑i=1⌊Nd⌋⌊Nid⌋∑j=1⌊Md⌋⌊Mjd⌋ \\begin{aligned}\\sum_{i=1}^{N}\\sum_{j=1}^{M}d(ij)&amp;=\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\sum_{p \\mid i}\\sum_{q \\mid j}[\\gcd(p,q)=1] \\\\ &amp;=\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\left \\lfloor \\frac {N} {i} \\right \\rfloor \\left \\lfloor \\frac {M} {j} \\right \\rfloor[\\gcd(i,j)=1] \\\\ &amp;=\\sum_{i=1}^{N}\\sum_{j=1}^{M}\\left \\lfloor \\frac {N} {i} \\right \\rfloor \\left \\lfloor \\frac {M} {j} \\right \\rfloor\\sum_{d \\mid \\gcd(i,j)}\\mu(d) \\\\ &amp;=\\sum_{d=1}^{N} \\mu(d) \\sum_{i=1}^{\\left \\lfloor \\frac {N} {d} \\right \\rfloor}\\sum_{j=1}^{\\left \\lfloor \\frac {M} {d} \\right \\rfloor }\\left \\lfloor\\frac{N}{id}\\right\\rfloor\\left \\lfloor\\frac{M}{jd}\\right\\rfloor \\\\ &amp;=\\sum_{d=1}^{N} \\mu(d) \\sum_{i=1}^{\\left \\lfloor \\frac {N} {d} \\right \\rfloor} \\left \\lfloor\\frac{N}{id}\\right\\rfloor\\sum_{j=1}^{\\left \\lfloor \\frac {M} {d} \\right \\rfloor }\\left \\lfloor\\frac{M}{jd}\\right\\rfloor\\end{aligned} ​​i=1​∑​N​​​j=1​∑​M​​d(ij)​​​​​​​=​i=1​∑​N​​​j=1​∑​M​​​p∣i​∑​​​q∣j​∑​​[gcd(p,q)=1]​=​i=1​∑​N​​​j=1​∑​M​​⌊​i​​N​​⌋⌊​j​​M​​⌋[gcd(i,j)=1]​=​i=1​∑​N​​​j=1​∑​M​​⌊​i​​N​​⌋⌊​j​​M​​⌋​d∣gcd(i,j)​∑​​μ(d)​=​d=1​∑​N​​μ(d)​i=1​∑​⌊​d​​N​​⌋​​​j=1​∑​⌊​d​​M​​⌋​​⌊​id​​N​​⌋⌊​jd​​M​​⌋​=​d=1​∑​N​​μ(d)​i=1​∑​⌊​d​​N​​⌋​​⌊​id​​N​​⌋​j=1​∑​⌊​d​​M​​⌋​​⌊​jd​​M​​⌋​​设g(n)=∑i=1n⌊ni⌋g(n)=\\sum_{i=1}^{n}\\left \\lfloor \\frac {n} {i}\\right \\rfloorg(n)=∑​i=1​n​​⌊​i​​n​​⌋，于是 ∑i=1N∑j=1Md(ij)=∑d=1Nμ(d)∑i=1⌊Nd⌋⌊⌊Nd⌋i⌋∑j=1⌊Md⌋⌊⌊Md⌋j⌋=∑d=1Nμ(d)g(⌊Nd⌋)g(⌊Md⌋) \\begin{aligned}\\sum_{i=1}^{N}\\sum_{j=1}^{M}d(ij)&amp;=\\sum_{d=1}^{N} \\mu(d) \\sum_{i=1}^{\\left \\lfloor \\frac {N} {d} \\right \\rfloor} \\left \\lfloor\\frac{\\left \\lfloor\\frac{N}{d}\\right\\rfloor}{i}\\right\\rfloor \\sum_{j=1}^{\\left \\lfloor \\frac {M} {d} \\right \\rfloor} \\left \\lfloor\\frac{\\left \\lfloor\\frac{M}{d}\\right\\rfloor}{j}\\right\\rfloor\\\\&amp;=\\sum_{d=1}^{N}\\mu(d)g(\\left \\lfloor\\frac{N}{d}\\right \\rfloor) g(\\left \\lfloor\\frac{M}{d}\\right\\rfloor)\\end{aligned} ​​i=1​∑​N​​​j=1​∑​M​​d(ij)​​​​=​d=1​∑​N​​μ(d)​i=1​∑​⌊​d​​N​​⌋​​⌊​i​​⌊​d​​N​​⌋​​⌋​j=1​∑​⌊​d​​M​​⌋​​⌊​j​​⌊​d​​M​​⌋​​⌋​=​d=1​∑​N​​μ(d)g(⌊​d​​N​​⌋)g(⌊​d​​M​​⌋)​​注意到ggg是ddd的前缀和，而ddd是积性函数，可以线性筛出ddd之后预处理出ggg。 之后用分块加速计算就可以了。 Code #include &lt;cctype&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int MAXSIZE=10000020; int bufpos; char buf[MAXSIZE]; void init(){ #ifdef LOCAL freopen(&quot;3994.txt&quot;,&quot;r&quot;,stdin); #endif // LOCAL buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } const int maxn=1000000; int prime[maxn+1],cur=0,u[maxn+1],c[maxn+1],d[maxn+1]; int sumu[maxn+1]; long long g[maxn+1]; bool notprime[maxn+1]; void sieve(){ notprime[1]=true; u[1]=d[1]=1; //c(1) is undefined for(int i=2;i&lt;=maxn;i++){ if (!notprime[i]){ prime[++cur]=i; u[i]=-1; c[i]=1; d[i]=2; //continue; } for(int j=1;j&lt;=cur &amp;&amp; i*prime[j]&lt;=maxn;j++){ int t=i*prime[j]; notprime[t]=true; if (i%prime[j]==0){ d[t]=d[i]/(c[i]+1)*(c[i]+2); c[t]=c[i]+1; u[t]=0; break; } u[t]=-u[i]; d[t]=d[i]*d[prime[j]]; c[t]=1; } } for(int i=1;i&lt;=maxn;i++) sumu[i]=sumu[i-1]+u[i],g[i]=g[i-1]+d[i]; } int main(){ init(); sieve(); int t=readint(); while(t--){ int n=readint(),m=readint(),w=min(n,m),nxt; long long ans=0; for(int i=1;i&lt;=w;i=nxt+1){ nxt=min(n/(n/i),m/(m/i)); ans+=(sumu[nxt]-sumu[i-1])*g[n/i]*g[m/i]; } printf(&quot;%lld\\n&quot;,ans); } }","tags":[{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://q234rty.top/tags/莫比乌斯反演/"}]},{"title":"【BZOJ1901】【ZJU2112】Dynamic Rankings","date":"2016-07-27T04:00:00.000Z","path":"2016/07/27/bzoj1901/","text":"树状数组套动态开点的权值线段树即可。 树状数组中的每个节点iii为满足jjj在 的所有a[j]a[j]a[j]组成的权值线段树。 修改操作对应树状数组的修改操作，但加法变成了权值线段树的插入，减法变成了权值线段树的删除。 查询对应在O(logn)O(\\log n)O(logn)棵权值线段树的加减操作的结果上查询第k小，直接同时在这O(logn)O(\\log n)O(logn)棵树上走即可。 需要离散化以减小空间。时空复杂度均为O(nlog2n)O(n \\log^2 n)O(nlog​2​​n)。 Code #include &lt;cctype&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #define rep(i,f,t) for(int i=(f);i&lt;=(t);i++) #define WTF using namespace std; const int MAXSIZE=10000020; int bufpos; char buf[MAXSIZE]; void init(){ #ifdef LOCAL freopen(&quot;1901.txt&quot;,&quot;r&quot;,stdin); #endif // LOCAL buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } char readchar(){ for(;isspace(buf[bufpos]);bufpos++); return buf[bufpos++]; } const int maxn=10001; const int maxm=10001; struct segkth{ private: static const int maxt=16*16*(maxn+maxm); struct node{ int sum,lson,rson; node(){ sum=lson=rson=0; } }; node t[maxt]; int n,cur; int p,v; void update(int&amp; o,int l,int r){ if (!o) o=++cur; t[o].sum+=v; //printf(&quot;o=%d,l=%d,r=%d\\n&quot;,o,l,r); if (l==r) return; int m=(l+r)/2; if (p&lt;=m) update(t[o].lson,l,m); else update(t[o].rson,m+1,r); } public: void init(int n,int maxv){ this-&gt;n=maxv; cur=n; } void ins(int c,int x){ p=x,v=1; update(c,1,n); } void del(int c,int x){ p=x,v=-1; update(c,1,n); } int kth(int k,int* add,int addc,int* dec,int decc){ int l=1,r=n,mid; while(l&lt;r){ //printf(&quot;l=%d,r=%d\\n&quot;,l,r); mid=(l+r)/2; int sz=0; rep(i,1,addc) sz+=t[t[add[i]].lson].sum; rep(i,1,decc) sz-=t[t[dec[i]].lson].sum; if (sz&gt;=k){ //left rep(i,1,addc) add[i]=t[add[i]].lson; rep(i,1,decc) dec[i]=t[dec[i]].lson; r=mid; }else{ //right k-=sz; rep(i,1,addc) add[i]=t[add[i]].rson; rep(i,1,decc) dec[i]=t[dec[i]].rson; l=mid+1; } } return l; } }t; struct bit{ private: static const int maxw=18; int n; int val[maxn]; int add[maxw],dec[maxw]; inline int lowbit(int x){ return x&amp;-x; } public: void init(int n,int *a,int maxv){ this-&gt;n=n; t.init(n,maxv); memcpy(val,a,sizeof(val)); rep(i,1,n) for(int j=i;j&lt;=n;j+=lowbit(j)) t.ins(j,val[i]); } void modify(int p,int v){ //WTF; for(int i=p;i&lt;=n;i+=lowbit(i)) t.del(i,val[p]),t.ins(i,v); val[p]=v; } int kth(int l,int r,int k){ //WTF; int addc=0,decc=0; for(int i=r;i;i-=lowbit(i)) add[++addc]=i; for(int i=l-1;i;i-=lowbit(i)) dec[++decc]=i; //WTF; return t.kth(k,add,addc,dec,decc); } }b; int a[maxn]; int nums[maxn+maxm],cur; struct query{ char c; int i,j,k; }q[maxm]; int main(){ init(); //WTF; int n=readint(),m=readint(); rep(i,1,n) a[i]=readint(),nums[++cur]=a[i]; rep(i,1,m){ q[i].c=readchar(),q[i].i=readint(),q[i].j=readint(); if (q[i].c==&#39;Q&#39;) q[i].k=readint(); else nums[++cur]=q[i].j; } //WTF; sort(nums+1,nums+cur+1); cur=unique(nums+1,nums+cur+1)-nums-1; rep(i,1,n) a[i]=lower_bound(nums+1,nums+cur+1,a[i])-nums; //WTF; b.init(n,a,cur); //WTF; rep(i,1,m){ //WTF; if (q[i].c==&#39;Q&#39;){ printf(&quot;%d\\n&quot;,nums[b.kth(q[i].i,q[i].j,q[i].k)]); } else { //WTF; b.modify(q[i].i,lower_bound(nums+1,nums+cur+1,q[i].j)-nums); } } }","tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://q234rty.top/tags/树状数组/"},{"name":"线段树","slug":"线段树","permalink":"https://q234rty.top/tags/线段树/"},{"name":"树套树","slug":"树套树","permalink":"https://q234rty.top/tags/树套树/"}]},{"title":"【UOJ150】【NOIP2015】运输计划","date":"2016-07-22T04:00:00.000Z","path":"2016/07/22/uoj150/","text":"二分答案+树上差分即可。 考虑到答案是所有任务所用时间的最大值，因此二分答案。 这样原问题就变成了一个判定性的问题：是否可以在给定时间内完成所有任务。 先预处理出所有方案两个点的lca，以及dfs序。 对于每个答案，显然改造成虫洞的边一是所有所用时间大于答案的任务对应的链的交上的边中边权最大的一条。 于是我们求出链的交，选择边权最大的一条边，判断所用时间最长的任务的时间减去最大边权后是否不大于答案即可。 那么如何求链交？注意到如果我们把一条链上的所有边对应的值都加上111,最后对应的值恰好等于链的个数的边一定是链交的一部分。我们定义对于每个点iii,其到根的路径上的所有边的值都要加上mark[i]mark[i]mark[i]。对于每条链，我们只要使其两端的点的markmarkmark值+1+1+1,其两端点的lca的markmarkmark值−2-2−2就可以啦。 对于每个点iii,我们定义val[i]val[i]val[i]为其子树中所有点的markmarkmark值之和不难发现这也是其到它父亲的边对应的值。 这样，只要按照dfs序从后往前扫，对于每个点iii把val[i]val[i]val[i]加上mark[i]mark[i]mark[i],并把val[fa[i]]val[fa[i]]val[fa[i]]加上val[i]val[i]val[i]。如果val[i]val[i]val[i]等于链的个数，说明点iii到其父亲的边是链交的一部分，更新最大值即可。 我使用了树链剖分求lca，时间复杂度O(nlog1000n)O(n\\log{1000n})O(nlog1000n)。 Code #include &lt;cctype&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int MAXSIZE=10000020; const int INF=0x3f3f3f3f; int bufpos; char buf[MAXSIZE]; void init(){ #ifdef LOCAL freopen(&quot;4326.txt&quot;,&quot;r&quot;,stdin); #endif // LOCAL buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } int readint(){ int val=0; for(;!isdigit(buf[bufpos]);bufpos++); for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return val; } const int maxn=300001; const int maxq=300001; const int maxm=600001; struct query{ int u,v,lc,len; bool operator &lt; (const query&amp; rhs)const{ return len&gt;rhs.len; } }; struct edge{ int to,cost,next; }; struct graph{ int n,m; edge e[maxm]; int first[maxn]; int dep[maxn],fa[maxn],top[maxn],sz[maxn],son[maxn],mark[maxn],dist[maxn],w[maxn],val[maxn],b[maxn]; query q[maxq]; int cur; void init(int n){ this-&gt;n=n; m=0; memset(first,0,sizeof(first)); } void addedge(int from,int to,int cost){ e[++m]=(edge){to,cost,first[from]}; first[from]=m; } void dfs(int u){ sz[u]=1; for(int i=first[u];i;i=e[i].next){ int v=e[i].to; if (dep[v]) continue; fa[v]=u; dep[v]=dep[u]+1; dist[v]=dist[u]+e[i].cost; w[v]=e[i].cost; dfs(v); sz[u]+=sz[v]; if (!son[u] || sz[v]&gt;sz[son[u]]) son[u]=v; } } void dfs2(int u,int tp){ top[u]=tp; b[++cur]=u; if (son[u]) dfs2(son[u],tp); for(int i=first[u];i;i=e[i].next){ int v=e[i].to; if (!top[v]) dfs2(v,v); } } void prepare(){ dep[1]=1; dist[1]=0; fa[1]=-1; dfs(1); cur=0; dfs2(1,1); cur=0; } int lca(int u,int v){ for(;top[u]!=top[v];u=fa[top[u]]) if (dep[top[u]]&lt;dep[top[v]]) swap(u,v); return dep[u]&lt;dep[v]?u:v; } void addquery(int u,int v){ //O(log n) int lc=lca(u,v); q[++cur]=(query){u,v,lc,dist[u]+dist[v]-2*dist[lc]}; } int num,mmax; bool check(int x){ //O(n) memset(mark,0,sizeof(mark)); memset(val,0,sizeof(val)); num=mmax=0; for(int i=1;q[i].len&gt;x &amp;&amp; i&lt;=cur;i++){ num++; mark[q[i].u]++; mark[q[i].v]++; mark[q[i].lc]-=2; } //puts(&quot;WTF&quot;); for(int i=n;i&gt;=2;i--){ val[b[i]]+=mark[b[i]]; if (val[b[i]]==num) mmax=max(mmax,w[b[i]]); val[fa[b[i]]]+=val[b[i]]; } //printf(&quot;check(%d)=%d\\n&quot;,x,(q[1].len-mmax)&lt;=x); return (q[1].len-mmax)&lt;=x; } int get(){ //O(nlogn) sort(q+1,q+cur+1); //binary search int low=0,high=q[1].len+1; while(low&lt;high){ int mid=(low+high)/2; if (check(mid)) high=mid; else low=mid+1; } return low; } }g; int main(){ init(); int n=readint(),m=readint(); g.init(n); for(int i=1;i&lt;=n-1;i++){ int x=readint(),y=readint(),z=readint(); g.addedge(x,y,z); g.addedge(y,x,z); } g.prepare(); //puts(&quot;WTF&quot;); for(int i=1;i&lt;=m;i++){ int u=readint(),v=readint(); g.addquery(u,v); } //puts(&quot;WTF&quot;); printf(&quot;%d\\n&quot;,g.get()); }","tags":[{"name":"二分","slug":"二分","permalink":"https://q234rty.top/tags/二分/"},{"name":"树上差分","slug":"树上差分","permalink":"https://q234rty.top/tags/树上差分/"}]},{"title":"【BZOJ1925】【SDOI2010】地精部落","date":"2016-07-08T04:00:00.000Z","path":"2016/07/08/bzoj1925/","text":"动态规划即可。 定义f(i,j)f(i,j)f(i,j)为[1,i][1,i][1,i]的排列， 第一个数为jjj，第二个数比第一个数小，且满足题目要求的方案数。 考虑第二个数： 当第二个数不是j−1j-1j−1时，交换jjj和j−1j-1j−1，注意到这两个数不相邻（因此互不影响）并且与其它数的大小关系相同，所以交换后得到的仍是合法的方案。所以此时的方案数为f(i,j−1)f(i,j-1)f(i,j−1)。 当第二个数是j−1j-1j−1时，去掉第一个数，并将所有x&gt;j−1x&gt;j-1x&gt;j−1变成x−1x-1x−1，此时原排列变成[1,i−1][1,i-1][1,i−1]的排列，且第二个数比第一个数大，并满足题目要求。将每个数xxx变成i−xi-xi−x，此时仍为[1,i−1][1,i-1][1,i−1]的排列，且第二个数比第一个数小，第一个数为i−j+1i-j+1i−j+1仍满足题目要求。于是方案数为f(i−1,i−j+1)f(i-1,i-j+1)f(i−1,i−j+1)。 于是f(i,j)=f(i,j−1)+f(i−1,i−j+1)f(i,j)=f(i,j-1)+f(i-1,i-j+1)f(i,j)=f(i,j−1)+f(i−1,i−j+1)，初值为f(1,1)=1f(1,1)=1f(1,1)=1。 最后ans=∑i=1nf(n,i)ans=\\sum_{i=1}^{n}f(n,i)ans=∑​i=1​n​​f(n,i) 用滚动数组实现，时间复杂度O(n2)O(n^2)O(n​2​​)，空间复杂度O(n)O(n)O(n)。 Code #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; int dp[2][4201]; int main(){ int n,p; scanf(&quot;%d%d&quot;,&amp;n,&amp;p); int cur=1; memset(dp[0],0,sizeof(dp[0])); dp[0][1]=1; for(int i=2;i&lt;=n;i++){ memset(dp[cur],0,sizeof(dp[cur])); for(int j=1;j&lt;=i;j++) dp[cur][j]=(dp[cur][j-1]+dp[cur^1][i-j+1])%p; cur^=1; } int ans=0; for(int i=1;i&lt;=n;i++) (ans+=dp[cur^1][i])%=p; printf(&quot;%d&quot;,ans*2%p); }","tags":[{"name":"DP","slug":"DP","permalink":"https://q234rty.top/tags/DP/"},{"name":"计数","slug":"计数","permalink":"https://q234rty.top/tags/计数/"}]},{"title":"【BZOJ1878】【SDOI2009】HH的项链","date":"2016-06-18T04:00:00.000Z","path":"2016/06/18/bzoj1878/","text":"离线处理+树状数组即可。 将询问按照左端点从小到大排序,之后从左到右扫一遍,t[i]t[i]t[i]表示贝壳iii是否是还没扫过的贝壳中这种颜色的贝壳的第一次出现. 预处理 表示 这种颜色的贝壳下一次出现的地方.一开始先把每个颜色第一次出现的贝壳 的 加上 .对于每个扫过的贝壳,给 加上 . 用树状数组维护t[i]t[i]t[i],询问的答案就是∑i=lrt[i]\\sum\\limits_{i=l}^r{t[i]}​i=l​∑​r​​t[i]. 于是这题就做完啦. 时间复杂度O((m+n)logn)O((m+n)\\log n)O((m+n)logn). Code #include &lt;cctype&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int MAXSIZE=30000020; int bufpos; char buf[MAXSIZE]; void init(){ #ifdef LOCAL freopen(&quot;1878.txt&quot;,&quot;r&quot;,stdin); #endif // LOCAL buf[fread(buf,1,MAXSIZE,stdin)]=&#39;\\0&#39;; bufpos=0; } int readint(){ bool isneg; int val=0; for(;!isdigit(buf[bufpos]) &amp;&amp; buf[bufpos]!=&#39;-&#39;;bufpos++); bufpos+=(isneg=(buf[bufpos]==&#39;-&#39;))?1:0; for(;isdigit(buf[bufpos]);bufpos++) val=val*10+buf[bufpos]-&#39;0&#39;; return isneg?-val:val; } struct bit{ int t[50001]; int n; void init(int n){ this-&gt;n=n; memset(t,0,sizeof(t)); } inline int lowbit(int x){ return (x&amp;(-x)); } int sum(int x){ int ret=0; for(int i=x;i&gt;0;i-=lowbit(i)) ret+=t[i]; return ret; } void add(int p,int v){ for(int i=p;i&lt;=n;i+=lowbit(i)) t[i]+=v; //for(int i=1;i&lt;=n;i++) //printf(&quot;%d &quot;,t[i]); } }t; int nxt[50001]; int now[1000001]; bool app[1000001]; int a[50001]; struct query{ int l,r,p; bool operator &lt;(const query&amp; rhs)const{ return l&lt;rhs.l; } }; query q[200001]; int ans[200001]; int main(){ init(); int n=readint(); t.init(n); for(int i=1;i&lt;=n;i++) a[i]=readint(); int m=readint(); for(int i=1;i&lt;=m;i++){ q[i].l=readint(),q[i].r=readint(),q[i].p=i; } sort(q+1,q+m+1); memset(now,-1,sizeof(now)); for(int i=n;i&gt;=1;i--){ nxt[i]=now[a[i]]; now[a[i]]=i; } for(int i=1;i&lt;=n;i++){ if (!app[a[i]]) t.add(i,1),app[a[i]]=true; } q[0].l=1; for(int i=1;i&lt;=m;i++){ for(int j=q[i-1].l;j&lt;q[i].l;j++) if (nxt[j]!=-1) t.add(nxt[j],1); ans[q[i].p]=t.sum(q[i].r)-t.sum(q[i].l-1); } for(int i=1;i&lt;=m;i++) printf(&quot;%d\\n&quot;,ans[i]); }","tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://q234rty.top/tags/树状数组/"},{"name":"离线","slug":"离线","permalink":"https://q234rty.top/tags/离线/"}]},{"title":"Templates","date":"2016-06-11T05:00:00.000Z","path":"2016/06/11/templates/","text":"一些奇怪的模板。 点这里","tags":[]},{"title":"Hello World","date":"2016-06-11T04:00:00.000Z","path":"2016/06/11/hello-world/","text":"终于搭好博客啦 Markdown KaTeX\\KaTeXKATEX #include &lt;cstdio&gt;","tags":[]}]